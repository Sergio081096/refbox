// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MachineInfo.proto

#ifndef PROTOBUF_INCLUDED_MachineInfo_2eproto
#define PROTOBUF_INCLUDED_MachineInfo_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Pose2D.pb.h"
#include "ProductColor.pb.h"
#include "Team.pb.h"
#include "Zone.pb.h"
#include "MachineInstructions.pb.h"
#include "MachineDescription.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_MachineInfo_2eproto 

namespace protobuf_MachineInfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_MachineInfo_2eproto
namespace llsf_msgs {
class LightSpec;
class LightSpecDefaultTypeInternal;
extern LightSpecDefaultTypeInternal _LightSpec_default_instance_;
class Machine;
class MachineDefaultTypeInternal;
extern MachineDefaultTypeInternal _Machine_default_instance_;
class MachineInfo;
class MachineInfoDefaultTypeInternal;
extern MachineInfoDefaultTypeInternal _MachineInfo_default_instance_;
class ShelfSlotInfo;
class ShelfSlotInfoDefaultTypeInternal;
extern ShelfSlotInfoDefaultTypeInternal _ShelfSlotInfo_default_instance_;
}  // namespace llsf_msgs
namespace google {
namespace protobuf {
template<> ::llsf_msgs::LightSpec* Arena::CreateMaybeMessage<::llsf_msgs::LightSpec>(Arena*);
template<> ::llsf_msgs::Machine* Arena::CreateMaybeMessage<::llsf_msgs::Machine>(Arena*);
template<> ::llsf_msgs::MachineInfo* Arena::CreateMaybeMessage<::llsf_msgs::MachineInfo>(Arena*);
template<> ::llsf_msgs::ShelfSlotInfo* Arena::CreateMaybeMessage<::llsf_msgs::ShelfSlotInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace llsf_msgs {

enum LightSpec_CompType {
  LightSpec_CompType_COMP_ID = 2000,
  LightSpec_CompType_MSG_TYPE = 10
};
bool LightSpec_CompType_IsValid(int value);
const LightSpec_CompType LightSpec_CompType_CompType_MIN = LightSpec_CompType_MSG_TYPE;
const LightSpec_CompType LightSpec_CompType_CompType_MAX = LightSpec_CompType_COMP_ID;
const int LightSpec_CompType_CompType_ARRAYSIZE = LightSpec_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LightSpec_CompType_descriptor();
inline const ::std::string& LightSpec_CompType_Name(LightSpec_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LightSpec_CompType_descriptor(), value);
}
inline bool LightSpec_CompType_Parse(
    const ::std::string& name, LightSpec_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightSpec_CompType>(
    LightSpec_CompType_descriptor(), name, value);
}
enum ShelfSlotInfo_CompType {
  ShelfSlotInfo_CompType_COMP_ID = 2000,
  ShelfSlotInfo_CompType_MSG_TYPE = 121
};
bool ShelfSlotInfo_CompType_IsValid(int value);
const ShelfSlotInfo_CompType ShelfSlotInfo_CompType_CompType_MIN = ShelfSlotInfo_CompType_MSG_TYPE;
const ShelfSlotInfo_CompType ShelfSlotInfo_CompType_CompType_MAX = ShelfSlotInfo_CompType_COMP_ID;
const int ShelfSlotInfo_CompType_CompType_ARRAYSIZE = ShelfSlotInfo_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShelfSlotInfo_CompType_descriptor();
inline const ::std::string& ShelfSlotInfo_CompType_Name(ShelfSlotInfo_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShelfSlotInfo_CompType_descriptor(), value);
}
inline bool ShelfSlotInfo_CompType_Parse(
    const ::std::string& name, ShelfSlotInfo_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShelfSlotInfo_CompType>(
    ShelfSlotInfo_CompType_descriptor(), name, value);
}
enum Machine_CompType {
  Machine_CompType_COMP_ID = 2000,
  Machine_CompType_MSG_TYPE = 12
};
bool Machine_CompType_IsValid(int value);
const Machine_CompType Machine_CompType_CompType_MIN = Machine_CompType_MSG_TYPE;
const Machine_CompType Machine_CompType_CompType_MAX = Machine_CompType_COMP_ID;
const int Machine_CompType_CompType_ARRAYSIZE = Machine_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Machine_CompType_descriptor();
inline const ::std::string& Machine_CompType_Name(Machine_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Machine_CompType_descriptor(), value);
}
inline bool Machine_CompType_Parse(
    const ::std::string& name, Machine_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Machine_CompType>(
    Machine_CompType_descriptor(), name, value);
}
enum MachineInfo_CompType {
  MachineInfo_CompType_COMP_ID = 2000,
  MachineInfo_CompType_MSG_TYPE = 13
};
bool MachineInfo_CompType_IsValid(int value);
const MachineInfo_CompType MachineInfo_CompType_CompType_MIN = MachineInfo_CompType_MSG_TYPE;
const MachineInfo_CompType MachineInfo_CompType_CompType_MAX = MachineInfo_CompType_COMP_ID;
const int MachineInfo_CompType_CompType_ARRAYSIZE = MachineInfo_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MachineInfo_CompType_descriptor();
inline const ::std::string& MachineInfo_CompType_Name(MachineInfo_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MachineInfo_CompType_descriptor(), value);
}
inline bool MachineInfo_CompType_Parse(
    const ::std::string& name, MachineInfo_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MachineInfo_CompType>(
    MachineInfo_CompType_descriptor(), name, value);
}
enum ExplorationState {
  NO_REPORT = 0,
  CORRECT_REPORT = 1,
  WRONG_REPORT = 2
};
bool ExplorationState_IsValid(int value);
const ExplorationState ExplorationState_MIN = NO_REPORT;
const ExplorationState ExplorationState_MAX = WRONG_REPORT;
const int ExplorationState_ARRAYSIZE = ExplorationState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExplorationState_descriptor();
inline const ::std::string& ExplorationState_Name(ExplorationState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExplorationState_descriptor(), value);
}
inline bool ExplorationState_Parse(
    const ::std::string& name, ExplorationState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExplorationState>(
    ExplorationState_descriptor(), name, value);
}
// ===================================================================

class LightSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.LightSpec) */ {
 public:
  LightSpec();
  virtual ~LightSpec();

  LightSpec(const LightSpec& from);

  inline LightSpec& operator=(const LightSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LightSpec(LightSpec&& from) noexcept
    : LightSpec() {
    *this = ::std::move(from);
  }

  inline LightSpec& operator=(LightSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LightSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LightSpec* internal_default_instance() {
    return reinterpret_cast<const LightSpec*>(
               &_LightSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LightSpec* other);
  friend void swap(LightSpec& a, LightSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LightSpec* New() const final {
    return CreateMaybeMessage<LightSpec>(NULL);
  }

  LightSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LightSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LightSpec& from);
  void MergeFrom(const LightSpec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LightSpec_CompType CompType;
  static const CompType COMP_ID =
    LightSpec_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    LightSpec_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return LightSpec_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    LightSpec_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    LightSpec_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    LightSpec_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return LightSpec_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return LightSpec_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return LightSpec_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .llsf_msgs.LightColor color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::llsf_msgs::LightColor color() const;
  void set_color(::llsf_msgs::LightColor value);

  // required .llsf_msgs.LightState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::llsf_msgs::LightState state() const;
  void set_state(::llsf_msgs::LightState value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.LightSpec)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int color_;
  int state_;
  friend struct ::protobuf_MachineInfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShelfSlotInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.ShelfSlotInfo) */ {
 public:
  ShelfSlotInfo();
  virtual ~ShelfSlotInfo();

  ShelfSlotInfo(const ShelfSlotInfo& from);

  inline ShelfSlotInfo& operator=(const ShelfSlotInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShelfSlotInfo(ShelfSlotInfo&& from) noexcept
    : ShelfSlotInfo() {
    *this = ::std::move(from);
  }

  inline ShelfSlotInfo& operator=(ShelfSlotInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShelfSlotInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShelfSlotInfo* internal_default_instance() {
    return reinterpret_cast<const ShelfSlotInfo*>(
               &_ShelfSlotInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ShelfSlotInfo* other);
  friend void swap(ShelfSlotInfo& a, ShelfSlotInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShelfSlotInfo* New() const final {
    return CreateMaybeMessage<ShelfSlotInfo>(NULL);
  }

  ShelfSlotInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShelfSlotInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShelfSlotInfo& from);
  void MergeFrom(const ShelfSlotInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShelfSlotInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShelfSlotInfo_CompType CompType;
  static const CompType COMP_ID =
    ShelfSlotInfo_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    ShelfSlotInfo_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return ShelfSlotInfo_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    ShelfSlotInfo_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    ShelfSlotInfo_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    ShelfSlotInfo_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return ShelfSlotInfo_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return ShelfSlotInfo_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return ShelfSlotInfo_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string description = 5;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // required uint32 shelf = 1;
  bool has_shelf() const;
  void clear_shelf();
  static const int kShelfFieldNumber = 1;
  ::google::protobuf::uint32 shelf() const;
  void set_shelf(::google::protobuf::uint32 value);

  // required uint32 slot = 2;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // required bool is_filled = 3;
  bool has_is_filled() const;
  void clear_is_filled();
  static const int kIsFilledFieldNumber = 3;
  bool is_filled() const;
  void set_is_filled(bool value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.ShelfSlotInfo)
 private:
  void set_has_shelf();
  void clear_has_shelf();
  void set_has_slot();
  void clear_has_slot();
  void set_has_is_filled();
  void clear_has_is_filled();
  void set_has_description();
  void clear_has_description();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 shelf_;
  ::google::protobuf::uint32 slot_;
  bool is_filled_;
  friend struct ::protobuf_MachineInfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.Machine) */ {
 public:
  Machine();
  virtual ~Machine();

  Machine(const Machine& from);

  inline Machine& operator=(const Machine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine(Machine&& from) noexcept
    : Machine() {
    *this = ::std::move(from);
  }

  inline Machine& operator=(Machine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine* internal_default_instance() {
    return reinterpret_cast<const Machine*>(
               &_Machine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Machine* other);
  friend void swap(Machine& a, Machine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine* New() const final {
    return CreateMaybeMessage<Machine>(NULL);
  }

  Machine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine& from);
  void MergeFrom(const Machine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Machine_CompType CompType;
  static const CompType COMP_ID =
    Machine_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    Machine_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return Machine_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    Machine_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    Machine_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    Machine_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return Machine_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return Machine_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return Machine_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .llsf_msgs.LightSpec lights = 7;
  int lights_size() const;
  void clear_lights();
  static const int kLightsFieldNumber = 7;
  ::llsf_msgs::LightSpec* mutable_lights(int index);
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::LightSpec >*
      mutable_lights();
  const ::llsf_msgs::LightSpec& lights(int index) const;
  ::llsf_msgs::LightSpec* add_lights();
  const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::LightSpec >&
      lights() const;

  // repeated .llsf_msgs.RingColor ring_colors = 14;
  int ring_colors_size() const;
  void clear_ring_colors();
  static const int kRingColorsFieldNumber = 14;
  ::llsf_msgs::RingColor ring_colors(int index) const;
  void set_ring_colors(int index, ::llsf_msgs::RingColor value);
  void add_ring_colors(::llsf_msgs::RingColor value);
  const ::google::protobuf::RepeatedField<int>& ring_colors() const;
  ::google::protobuf::RepeatedField<int>* mutable_ring_colors();

  // repeated .llsf_msgs.ShelfSlotInfo status_ss = 25;
  int status_ss_size() const;
  void clear_status_ss();
  static const int kStatusSsFieldNumber = 25;
  ::llsf_msgs::ShelfSlotInfo* mutable_status_ss(int index);
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::ShelfSlotInfo >*
      mutable_status_ss();
  const ::llsf_msgs::ShelfSlotInfo& status_ss(int index) const;
  ::llsf_msgs::ShelfSlotInfo* add_status_ss();
  const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::ShelfSlotInfo >&
      status_ss() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // optional .llsf_msgs.Pose2D pose = 8;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 8;
  private:
  const ::llsf_msgs::Pose2D& _internal_pose() const;
  public:
  const ::llsf_msgs::Pose2D& pose() const;
  ::llsf_msgs::Pose2D* release_pose();
  ::llsf_msgs::Pose2D* mutable_pose();
  void set_allocated_pose(::llsf_msgs::Pose2D* pose);

  // optional .llsf_msgs.PrepareInstructionBS instruction_bs = 16;
  bool has_instruction_bs() const;
  void clear_instruction_bs();
  static const int kInstructionBsFieldNumber = 16;
  private:
  const ::llsf_msgs::PrepareInstructionBS& _internal_instruction_bs() const;
  public:
  const ::llsf_msgs::PrepareInstructionBS& instruction_bs() const;
  ::llsf_msgs::PrepareInstructionBS* release_instruction_bs();
  ::llsf_msgs::PrepareInstructionBS* mutable_instruction_bs();
  void set_allocated_instruction_bs(::llsf_msgs::PrepareInstructionBS* instruction_bs);

  // optional .llsf_msgs.PrepareInstructionDS instruction_ds = 17;
  bool has_instruction_ds() const;
  void clear_instruction_ds();
  static const int kInstructionDsFieldNumber = 17;
  private:
  const ::llsf_msgs::PrepareInstructionDS& _internal_instruction_ds() const;
  public:
  const ::llsf_msgs::PrepareInstructionDS& instruction_ds() const;
  ::llsf_msgs::PrepareInstructionDS* release_instruction_ds();
  ::llsf_msgs::PrepareInstructionDS* mutable_instruction_ds();
  void set_allocated_instruction_ds(::llsf_msgs::PrepareInstructionDS* instruction_ds);

  // optional .llsf_msgs.PrepareInstructionRS instruction_rs = 18;
  bool has_instruction_rs() const;
  void clear_instruction_rs();
  static const int kInstructionRsFieldNumber = 18;
  private:
  const ::llsf_msgs::PrepareInstructionRS& _internal_instruction_rs() const;
  public:
  const ::llsf_msgs::PrepareInstructionRS& instruction_rs() const;
  ::llsf_msgs::PrepareInstructionRS* release_instruction_rs();
  ::llsf_msgs::PrepareInstructionRS* mutable_instruction_rs();
  void set_allocated_instruction_rs(::llsf_msgs::PrepareInstructionRS* instruction_rs);

  // optional .llsf_msgs.PrepareInstructionCS instruction_cs = 19;
  bool has_instruction_cs() const;
  void clear_instruction_cs();
  static const int kInstructionCsFieldNumber = 19;
  private:
  const ::llsf_msgs::PrepareInstructionCS& _internal_instruction_cs() const;
  public:
  const ::llsf_msgs::PrepareInstructionCS& instruction_cs() const;
  ::llsf_msgs::PrepareInstructionCS* release_instruction_cs();
  ::llsf_msgs::PrepareInstructionCS* mutable_instruction_cs();
  void set_allocated_instruction_cs(::llsf_msgs::PrepareInstructionCS* instruction_cs);

  // optional .llsf_msgs.PrepareInstructionSS instruction_ss = 20;
  bool has_instruction_ss() const;
  void clear_instruction_ss();
  static const int kInstructionSsFieldNumber = 20;
  private:
  const ::llsf_msgs::PrepareInstructionSS& _internal_instruction_ss() const;
  public:
  const ::llsf_msgs::PrepareInstructionSS& instruction_ss() const;
  ::llsf_msgs::PrepareInstructionSS* release_instruction_ss();
  ::llsf_msgs::PrepareInstructionSS* mutable_instruction_ss();
  void set_allocated_instruction_ss(::llsf_msgs::PrepareInstructionSS* instruction_ss);

  // optional bool correctly_reported = 9;
  bool has_correctly_reported() const;
  void clear_correctly_reported();
  static const int kCorrectlyReportedFieldNumber = 9;
  bool correctly_reported() const;
  void set_correctly_reported(bool value);

  // optional .llsf_msgs.Team team_color = 10;
  bool has_team_color() const;
  void clear_team_color();
  static const int kTeamColorFieldNumber = 10;
  ::llsf_msgs::Team team_color() const;
  void set_team_color(::llsf_msgs::Team value);

  // optional uint32 rotation = 12;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 12;
  ::google::protobuf::uint32 rotation() const;
  void set_rotation(::google::protobuf::uint32 value);

  // optional uint32 loaded_with = 13 [default = 0];
  bool has_loaded_with() const;
  void clear_loaded_with();
  static const int kLoadedWithFieldNumber = 13;
  ::google::protobuf::uint32 loaded_with() const;
  void set_loaded_with(::google::protobuf::uint32 value);

  // optional .llsf_msgs.ExplorationState exploration_rotation_state = 21;
  bool has_exploration_rotation_state() const;
  void clear_exploration_rotation_state();
  static const int kExplorationRotationStateFieldNumber = 21;
  ::llsf_msgs::ExplorationState exploration_rotation_state() const;
  void set_exploration_rotation_state(::llsf_msgs::ExplorationState value);

  // optional .llsf_msgs.ExplorationState exploration_zone_state = 22;
  bool has_exploration_zone_state() const;
  void clear_exploration_zone_state();
  static const int kExplorationZoneStateFieldNumber = 22;
  ::llsf_msgs::ExplorationState exploration_zone_state() const;
  void set_exploration_zone_state(::llsf_msgs::ExplorationState value);

  // optional .llsf_msgs.Zone zone = 11;
  bool has_zone() const;
  void clear_zone();
  static const int kZoneFieldNumber = 11;
  ::llsf_msgs::Zone zone() const;
  void set_zone(::llsf_msgs::Zone value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.Machine)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_team_color();
  void clear_has_team_color();
  void set_has_pose();
  void clear_has_pose();
  void set_has_zone();
  void clear_has_zone();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_correctly_reported();
  void clear_has_correctly_reported();
  void set_has_loaded_with();
  void clear_has_loaded_with();
  void set_has_instruction_bs();
  void clear_has_instruction_bs();
  void set_has_instruction_ds();
  void clear_has_instruction_ds();
  void set_has_instruction_ss();
  void clear_has_instruction_ss();
  void set_has_instruction_rs();
  void clear_has_instruction_rs();
  void set_has_instruction_cs();
  void clear_has_instruction_cs();
  void set_has_exploration_rotation_state();
  void clear_has_exploration_rotation_state();
  void set_has_exploration_zone_state();
  void clear_has_exploration_zone_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::LightSpec > lights_;
  ::google::protobuf::RepeatedField<int> ring_colors_;
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::ShelfSlotInfo > status_ss_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::llsf_msgs::Pose2D* pose_;
  ::llsf_msgs::PrepareInstructionBS* instruction_bs_;
  ::llsf_msgs::PrepareInstructionDS* instruction_ds_;
  ::llsf_msgs::PrepareInstructionRS* instruction_rs_;
  ::llsf_msgs::PrepareInstructionCS* instruction_cs_;
  ::llsf_msgs::PrepareInstructionSS* instruction_ss_;
  bool correctly_reported_;
  int team_color_;
  ::google::protobuf::uint32 rotation_;
  ::google::protobuf::uint32 loaded_with_;
  int exploration_rotation_state_;
  int exploration_zone_state_;
  int zone_;
  friend struct ::protobuf_MachineInfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MachineInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.MachineInfo) */ {
 public:
  MachineInfo();
  virtual ~MachineInfo();

  MachineInfo(const MachineInfo& from);

  inline MachineInfo& operator=(const MachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MachineInfo(MachineInfo&& from) noexcept
    : MachineInfo() {
    *this = ::std::move(from);
  }

  inline MachineInfo& operator=(MachineInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MachineInfo* internal_default_instance() {
    return reinterpret_cast<const MachineInfo*>(
               &_MachineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MachineInfo* other);
  friend void swap(MachineInfo& a, MachineInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MachineInfo* New() const final {
    return CreateMaybeMessage<MachineInfo>(NULL);
  }

  MachineInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MachineInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MachineInfo& from);
  void MergeFrom(const MachineInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MachineInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MachineInfo_CompType CompType;
  static const CompType COMP_ID =
    MachineInfo_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    MachineInfo_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return MachineInfo_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    MachineInfo_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    MachineInfo_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    MachineInfo_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return MachineInfo_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return MachineInfo_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return MachineInfo_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .llsf_msgs.Machine machines = 1;
  int machines_size() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 1;
  ::llsf_msgs::Machine* mutable_machines(int index);
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::Machine >*
      mutable_machines();
  const ::llsf_msgs::Machine& machines(int index) const;
  ::llsf_msgs::Machine* add_machines();
  const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::Machine >&
      machines() const;

  // optional .llsf_msgs.Team team_color = 2;
  bool has_team_color() const;
  void clear_team_color();
  static const int kTeamColorFieldNumber = 2;
  ::llsf_msgs::Team team_color() const;
  void set_team_color(::llsf_msgs::Team value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.MachineInfo)
 private:
  void set_has_team_color();
  void clear_has_team_color();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::Machine > machines_;
  int team_color_;
  friend struct ::protobuf_MachineInfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LightSpec

// required .llsf_msgs.LightColor color = 1;
inline bool LightSpec::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LightSpec::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LightSpec::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LightSpec::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::llsf_msgs::LightColor LightSpec::color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.LightSpec.color)
  return static_cast< ::llsf_msgs::LightColor >(color_);
}
inline void LightSpec::set_color(::llsf_msgs::LightColor value) {
  assert(::llsf_msgs::LightColor_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.LightSpec.color)
}

// required .llsf_msgs.LightState state = 2;
inline bool LightSpec::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LightSpec::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LightSpec::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LightSpec::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::llsf_msgs::LightState LightSpec::state() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.LightSpec.state)
  return static_cast< ::llsf_msgs::LightState >(state_);
}
inline void LightSpec::set_state(::llsf_msgs::LightState value) {
  assert(::llsf_msgs::LightState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.LightSpec.state)
}

// -------------------------------------------------------------------

// ShelfSlotInfo

// required uint32 shelf = 1;
inline bool ShelfSlotInfo::has_shelf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShelfSlotInfo::set_has_shelf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShelfSlotInfo::clear_has_shelf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShelfSlotInfo::clear_shelf() {
  shelf_ = 0u;
  clear_has_shelf();
}
inline ::google::protobuf::uint32 ShelfSlotInfo::shelf() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ShelfSlotInfo.shelf)
  return shelf_;
}
inline void ShelfSlotInfo::set_shelf(::google::protobuf::uint32 value) {
  set_has_shelf();
  shelf_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.ShelfSlotInfo.shelf)
}

// required uint32 slot = 2;
inline bool ShelfSlotInfo::has_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShelfSlotInfo::set_has_slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShelfSlotInfo::clear_has_slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShelfSlotInfo::clear_slot() {
  slot_ = 0u;
  clear_has_slot();
}
inline ::google::protobuf::uint32 ShelfSlotInfo::slot() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ShelfSlotInfo.slot)
  return slot_;
}
inline void ShelfSlotInfo::set_slot(::google::protobuf::uint32 value) {
  set_has_slot();
  slot_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.ShelfSlotInfo.slot)
}

// required bool is_filled = 3;
inline bool ShelfSlotInfo::has_is_filled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShelfSlotInfo::set_has_is_filled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShelfSlotInfo::clear_has_is_filled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShelfSlotInfo::clear_is_filled() {
  is_filled_ = false;
  clear_has_is_filled();
}
inline bool ShelfSlotInfo::is_filled() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ShelfSlotInfo.is_filled)
  return is_filled_;
}
inline void ShelfSlotInfo::set_is_filled(bool value) {
  set_has_is_filled();
  is_filled_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.ShelfSlotInfo.is_filled)
}

// optional string description = 5;
inline bool ShelfSlotInfo::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShelfSlotInfo::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShelfSlotInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShelfSlotInfo::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ShelfSlotInfo::description() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ShelfSlotInfo.description)
  return description_.GetNoArena();
}
inline void ShelfSlotInfo::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.ShelfSlotInfo.description)
}
#if LANG_CXX11
inline void ShelfSlotInfo::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.ShelfSlotInfo.description)
}
#endif
inline void ShelfSlotInfo::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.ShelfSlotInfo.description)
}
inline void ShelfSlotInfo::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.ShelfSlotInfo.description)
}
inline ::std::string* ShelfSlotInfo::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.ShelfSlotInfo.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShelfSlotInfo::release_description() {
  // @@protoc_insertion_point(field_release:llsf_msgs.ShelfSlotInfo.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShelfSlotInfo::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.ShelfSlotInfo.description)
}

// -------------------------------------------------------------------

// Machine

// required string name = 1;
inline bool Machine::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Machine::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Machine::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Machine::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Machine::name() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.name)
  return name_.GetNoArena();
}
inline void Machine::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.name)
}
#if LANG_CXX11
inline void Machine::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Machine.name)
}
#endif
inline void Machine::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Machine.name)
}
inline void Machine::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Machine.name)
}
inline ::std::string* Machine::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_name() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.name)
}

// optional string type = 2;
inline bool Machine::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Machine::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Machine::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Machine::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Machine::type() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.type)
  return type_.GetNoArena();
}
inline void Machine::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.type)
}
#if LANG_CXX11
inline void Machine::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Machine.type)
}
#endif
inline void Machine::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Machine.type)
}
inline void Machine::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Machine.type)
}
inline ::std::string* Machine::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_type() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.type)
}

// optional string state = 3;
inline bool Machine::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Machine::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Machine::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Machine::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& Machine::state() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.state)
  return state_.GetNoArena();
}
inline void Machine::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.state)
}
#if LANG_CXX11
inline void Machine::set_state(::std::string&& value) {
  set_has_state();
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Machine.state)
}
#endif
inline void Machine::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Machine.state)
}
inline void Machine::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Machine.state)
}
inline ::std::string* Machine::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_state() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.state)
  if (!has_state()) {
    return NULL;
  }
  clear_has_state();
  return state_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.state)
}

// optional .llsf_msgs.Team team_color = 10;
inline bool Machine::has_team_color() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Machine::set_has_team_color() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Machine::clear_has_team_color() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Machine::clear_team_color() {
  team_color_ = 0;
  clear_has_team_color();
}
inline ::llsf_msgs::Team Machine::team_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.team_color)
  return static_cast< ::llsf_msgs::Team >(team_color_);
}
inline void Machine::set_team_color(::llsf_msgs::Team value) {
  assert(::llsf_msgs::Team_IsValid(value));
  set_has_team_color();
  team_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.team_color)
}

// repeated .llsf_msgs.LightSpec lights = 7;
inline int Machine::lights_size() const {
  return lights_.size();
}
inline void Machine::clear_lights() {
  lights_.Clear();
}
inline ::llsf_msgs::LightSpec* Machine::mutable_lights(int index) {
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.lights)
  return lights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::llsf_msgs::LightSpec >*
Machine::mutable_lights() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.Machine.lights)
  return &lights_;
}
inline const ::llsf_msgs::LightSpec& Machine::lights(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.lights)
  return lights_.Get(index);
}
inline ::llsf_msgs::LightSpec* Machine::add_lights() {
  // @@protoc_insertion_point(field_add:llsf_msgs.Machine.lights)
  return lights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::LightSpec >&
Machine::lights() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.Machine.lights)
  return lights_;
}

// optional .llsf_msgs.Pose2D pose = 8;
inline bool Machine::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Machine::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Machine::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::llsf_msgs::Pose2D& Machine::_internal_pose() const {
  return *pose_;
}
inline const ::llsf_msgs::Pose2D& Machine::pose() const {
  const ::llsf_msgs::Pose2D* p = pose_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Pose2D*>(
      &::llsf_msgs::_Pose2D_default_instance_);
}
inline ::llsf_msgs::Pose2D* Machine::release_pose() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.pose)
  clear_has_pose();
  ::llsf_msgs::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::llsf_msgs::Pose2D* Machine::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Pose2D>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.pose)
  return pose_;
}
inline void Machine::set_allocated_pose(::llsf_msgs::Pose2D* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.pose)
}

// optional .llsf_msgs.Zone zone = 11;
inline bool Machine::has_zone() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Machine::set_has_zone() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Machine::clear_has_zone() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Machine::clear_zone() {
  zone_ = 18;
  clear_has_zone();
}
inline ::llsf_msgs::Zone Machine::zone() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.zone)
  return static_cast< ::llsf_msgs::Zone >(zone_);
}
inline void Machine::set_zone(::llsf_msgs::Zone value) {
  assert(::llsf_msgs::Zone_IsValid(value));
  set_has_zone();
  zone_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.zone)
}

// optional uint32 rotation = 12;
inline bool Machine::has_rotation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Machine::set_has_rotation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Machine::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Machine::clear_rotation() {
  rotation_ = 0u;
  clear_has_rotation();
}
inline ::google::protobuf::uint32 Machine::rotation() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.rotation)
  return rotation_;
}
inline void Machine::set_rotation(::google::protobuf::uint32 value) {
  set_has_rotation();
  rotation_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.rotation)
}

// optional bool correctly_reported = 9;
inline bool Machine::has_correctly_reported() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Machine::set_has_correctly_reported() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Machine::clear_has_correctly_reported() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Machine::clear_correctly_reported() {
  correctly_reported_ = false;
  clear_has_correctly_reported();
}
inline bool Machine::correctly_reported() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.correctly_reported)
  return correctly_reported_;
}
inline void Machine::set_correctly_reported(bool value) {
  set_has_correctly_reported();
  correctly_reported_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.correctly_reported)
}

// optional uint32 loaded_with = 13 [default = 0];
inline bool Machine::has_loaded_with() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Machine::set_has_loaded_with() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Machine::clear_has_loaded_with() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Machine::clear_loaded_with() {
  loaded_with_ = 0u;
  clear_has_loaded_with();
}
inline ::google::protobuf::uint32 Machine::loaded_with() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.loaded_with)
  return loaded_with_;
}
inline void Machine::set_loaded_with(::google::protobuf::uint32 value) {
  set_has_loaded_with();
  loaded_with_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.loaded_with)
}

// repeated .llsf_msgs.RingColor ring_colors = 14;
inline int Machine::ring_colors_size() const {
  return ring_colors_.size();
}
inline void Machine::clear_ring_colors() {
  ring_colors_.Clear();
}
inline ::llsf_msgs::RingColor Machine::ring_colors(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.ring_colors)
  return static_cast< ::llsf_msgs::RingColor >(ring_colors_.Get(index));
}
inline void Machine::set_ring_colors(int index, ::llsf_msgs::RingColor value) {
  assert(::llsf_msgs::RingColor_IsValid(value));
  ring_colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.ring_colors)
}
inline void Machine::add_ring_colors(::llsf_msgs::RingColor value) {
  assert(::llsf_msgs::RingColor_IsValid(value));
  ring_colors_.Add(value);
  // @@protoc_insertion_point(field_add:llsf_msgs.Machine.ring_colors)
}
inline const ::google::protobuf::RepeatedField<int>&
Machine::ring_colors() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.Machine.ring_colors)
  return ring_colors_;
}
inline ::google::protobuf::RepeatedField<int>*
Machine::mutable_ring_colors() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.Machine.ring_colors)
  return &ring_colors_;
}

// optional .llsf_msgs.PrepareInstructionBS instruction_bs = 16;
inline bool Machine::has_instruction_bs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Machine::set_has_instruction_bs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Machine::clear_has_instruction_bs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::llsf_msgs::PrepareInstructionBS& Machine::_internal_instruction_bs() const {
  return *instruction_bs_;
}
inline const ::llsf_msgs::PrepareInstructionBS& Machine::instruction_bs() const {
  const ::llsf_msgs::PrepareInstructionBS* p = instruction_bs_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.instruction_bs)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::PrepareInstructionBS*>(
      &::llsf_msgs::_PrepareInstructionBS_default_instance_);
}
inline ::llsf_msgs::PrepareInstructionBS* Machine::release_instruction_bs() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.instruction_bs)
  clear_has_instruction_bs();
  ::llsf_msgs::PrepareInstructionBS* temp = instruction_bs_;
  instruction_bs_ = NULL;
  return temp;
}
inline ::llsf_msgs::PrepareInstructionBS* Machine::mutable_instruction_bs() {
  set_has_instruction_bs();
  if (instruction_bs_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::PrepareInstructionBS>(GetArenaNoVirtual());
    instruction_bs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.instruction_bs)
  return instruction_bs_;
}
inline void Machine::set_allocated_instruction_bs(::llsf_msgs::PrepareInstructionBS* instruction_bs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instruction_bs_);
  }
  if (instruction_bs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instruction_bs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instruction_bs, submessage_arena);
    }
    set_has_instruction_bs();
  } else {
    clear_has_instruction_bs();
  }
  instruction_bs_ = instruction_bs;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.instruction_bs)
}

// optional .llsf_msgs.PrepareInstructionDS instruction_ds = 17;
inline bool Machine::has_instruction_ds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Machine::set_has_instruction_ds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Machine::clear_has_instruction_ds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::llsf_msgs::PrepareInstructionDS& Machine::_internal_instruction_ds() const {
  return *instruction_ds_;
}
inline const ::llsf_msgs::PrepareInstructionDS& Machine::instruction_ds() const {
  const ::llsf_msgs::PrepareInstructionDS* p = instruction_ds_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.instruction_ds)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::PrepareInstructionDS*>(
      &::llsf_msgs::_PrepareInstructionDS_default_instance_);
}
inline ::llsf_msgs::PrepareInstructionDS* Machine::release_instruction_ds() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.instruction_ds)
  clear_has_instruction_ds();
  ::llsf_msgs::PrepareInstructionDS* temp = instruction_ds_;
  instruction_ds_ = NULL;
  return temp;
}
inline ::llsf_msgs::PrepareInstructionDS* Machine::mutable_instruction_ds() {
  set_has_instruction_ds();
  if (instruction_ds_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::PrepareInstructionDS>(GetArenaNoVirtual());
    instruction_ds_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.instruction_ds)
  return instruction_ds_;
}
inline void Machine::set_allocated_instruction_ds(::llsf_msgs::PrepareInstructionDS* instruction_ds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instruction_ds_);
  }
  if (instruction_ds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instruction_ds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instruction_ds, submessage_arena);
    }
    set_has_instruction_ds();
  } else {
    clear_has_instruction_ds();
  }
  instruction_ds_ = instruction_ds;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.instruction_ds)
}

// optional .llsf_msgs.PrepareInstructionSS instruction_ss = 20;
inline bool Machine::has_instruction_ss() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Machine::set_has_instruction_ss() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Machine::clear_has_instruction_ss() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::llsf_msgs::PrepareInstructionSS& Machine::_internal_instruction_ss() const {
  return *instruction_ss_;
}
inline const ::llsf_msgs::PrepareInstructionSS& Machine::instruction_ss() const {
  const ::llsf_msgs::PrepareInstructionSS* p = instruction_ss_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.instruction_ss)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::PrepareInstructionSS*>(
      &::llsf_msgs::_PrepareInstructionSS_default_instance_);
}
inline ::llsf_msgs::PrepareInstructionSS* Machine::release_instruction_ss() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.instruction_ss)
  clear_has_instruction_ss();
  ::llsf_msgs::PrepareInstructionSS* temp = instruction_ss_;
  instruction_ss_ = NULL;
  return temp;
}
inline ::llsf_msgs::PrepareInstructionSS* Machine::mutable_instruction_ss() {
  set_has_instruction_ss();
  if (instruction_ss_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::PrepareInstructionSS>(GetArenaNoVirtual());
    instruction_ss_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.instruction_ss)
  return instruction_ss_;
}
inline void Machine::set_allocated_instruction_ss(::llsf_msgs::PrepareInstructionSS* instruction_ss) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instruction_ss_);
  }
  if (instruction_ss) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instruction_ss = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instruction_ss, submessage_arena);
    }
    set_has_instruction_ss();
  } else {
    clear_has_instruction_ss();
  }
  instruction_ss_ = instruction_ss;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.instruction_ss)
}

// optional .llsf_msgs.PrepareInstructionRS instruction_rs = 18;
inline bool Machine::has_instruction_rs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Machine::set_has_instruction_rs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Machine::clear_has_instruction_rs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::llsf_msgs::PrepareInstructionRS& Machine::_internal_instruction_rs() const {
  return *instruction_rs_;
}
inline const ::llsf_msgs::PrepareInstructionRS& Machine::instruction_rs() const {
  const ::llsf_msgs::PrepareInstructionRS* p = instruction_rs_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.instruction_rs)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::PrepareInstructionRS*>(
      &::llsf_msgs::_PrepareInstructionRS_default_instance_);
}
inline ::llsf_msgs::PrepareInstructionRS* Machine::release_instruction_rs() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.instruction_rs)
  clear_has_instruction_rs();
  ::llsf_msgs::PrepareInstructionRS* temp = instruction_rs_;
  instruction_rs_ = NULL;
  return temp;
}
inline ::llsf_msgs::PrepareInstructionRS* Machine::mutable_instruction_rs() {
  set_has_instruction_rs();
  if (instruction_rs_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::PrepareInstructionRS>(GetArenaNoVirtual());
    instruction_rs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.instruction_rs)
  return instruction_rs_;
}
inline void Machine::set_allocated_instruction_rs(::llsf_msgs::PrepareInstructionRS* instruction_rs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instruction_rs_);
  }
  if (instruction_rs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instruction_rs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instruction_rs, submessage_arena);
    }
    set_has_instruction_rs();
  } else {
    clear_has_instruction_rs();
  }
  instruction_rs_ = instruction_rs;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.instruction_rs)
}

// optional .llsf_msgs.PrepareInstructionCS instruction_cs = 19;
inline bool Machine::has_instruction_cs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Machine::set_has_instruction_cs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Machine::clear_has_instruction_cs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::llsf_msgs::PrepareInstructionCS& Machine::_internal_instruction_cs() const {
  return *instruction_cs_;
}
inline const ::llsf_msgs::PrepareInstructionCS& Machine::instruction_cs() const {
  const ::llsf_msgs::PrepareInstructionCS* p = instruction_cs_;
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.instruction_cs)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::PrepareInstructionCS*>(
      &::llsf_msgs::_PrepareInstructionCS_default_instance_);
}
inline ::llsf_msgs::PrepareInstructionCS* Machine::release_instruction_cs() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Machine.instruction_cs)
  clear_has_instruction_cs();
  ::llsf_msgs::PrepareInstructionCS* temp = instruction_cs_;
  instruction_cs_ = NULL;
  return temp;
}
inline ::llsf_msgs::PrepareInstructionCS* Machine::mutable_instruction_cs() {
  set_has_instruction_cs();
  if (instruction_cs_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::PrepareInstructionCS>(GetArenaNoVirtual());
    instruction_cs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.instruction_cs)
  return instruction_cs_;
}
inline void Machine::set_allocated_instruction_cs(::llsf_msgs::PrepareInstructionCS* instruction_cs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instruction_cs_);
  }
  if (instruction_cs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instruction_cs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instruction_cs, submessage_arena);
    }
    set_has_instruction_cs();
  } else {
    clear_has_instruction_cs();
  }
  instruction_cs_ = instruction_cs;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Machine.instruction_cs)
}

// optional .llsf_msgs.ExplorationState exploration_rotation_state = 21;
inline bool Machine::has_exploration_rotation_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Machine::set_has_exploration_rotation_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Machine::clear_has_exploration_rotation_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Machine::clear_exploration_rotation_state() {
  exploration_rotation_state_ = 0;
  clear_has_exploration_rotation_state();
}
inline ::llsf_msgs::ExplorationState Machine::exploration_rotation_state() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.exploration_rotation_state)
  return static_cast< ::llsf_msgs::ExplorationState >(exploration_rotation_state_);
}
inline void Machine::set_exploration_rotation_state(::llsf_msgs::ExplorationState value) {
  assert(::llsf_msgs::ExplorationState_IsValid(value));
  set_has_exploration_rotation_state();
  exploration_rotation_state_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.exploration_rotation_state)
}

// optional .llsf_msgs.ExplorationState exploration_zone_state = 22;
inline bool Machine::has_exploration_zone_state() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Machine::set_has_exploration_zone_state() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Machine::clear_has_exploration_zone_state() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Machine::clear_exploration_zone_state() {
  exploration_zone_state_ = 0;
  clear_has_exploration_zone_state();
}
inline ::llsf_msgs::ExplorationState Machine::exploration_zone_state() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.exploration_zone_state)
  return static_cast< ::llsf_msgs::ExplorationState >(exploration_zone_state_);
}
inline void Machine::set_exploration_zone_state(::llsf_msgs::ExplorationState value) {
  assert(::llsf_msgs::ExplorationState_IsValid(value));
  set_has_exploration_zone_state();
  exploration_zone_state_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.Machine.exploration_zone_state)
}

// repeated .llsf_msgs.ShelfSlotInfo status_ss = 25;
inline int Machine::status_ss_size() const {
  return status_ss_.size();
}
inline void Machine::clear_status_ss() {
  status_ss_.Clear();
}
inline ::llsf_msgs::ShelfSlotInfo* Machine::mutable_status_ss(int index) {
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Machine.status_ss)
  return status_ss_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::llsf_msgs::ShelfSlotInfo >*
Machine::mutable_status_ss() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.Machine.status_ss)
  return &status_ss_;
}
inline const ::llsf_msgs::ShelfSlotInfo& Machine::status_ss(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Machine.status_ss)
  return status_ss_.Get(index);
}
inline ::llsf_msgs::ShelfSlotInfo* Machine::add_status_ss() {
  // @@protoc_insertion_point(field_add:llsf_msgs.Machine.status_ss)
  return status_ss_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::ShelfSlotInfo >&
Machine::status_ss() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.Machine.status_ss)
  return status_ss_;
}

// -------------------------------------------------------------------

// MachineInfo

// repeated .llsf_msgs.Machine machines = 1;
inline int MachineInfo::machines_size() const {
  return machines_.size();
}
inline void MachineInfo::clear_machines() {
  machines_.Clear();
}
inline ::llsf_msgs::Machine* MachineInfo::mutable_machines(int index) {
  // @@protoc_insertion_point(field_mutable:llsf_msgs.MachineInfo.machines)
  return machines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::llsf_msgs::Machine >*
MachineInfo::mutable_machines() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.MachineInfo.machines)
  return &machines_;
}
inline const ::llsf_msgs::Machine& MachineInfo::machines(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.MachineInfo.machines)
  return machines_.Get(index);
}
inline ::llsf_msgs::Machine* MachineInfo::add_machines() {
  // @@protoc_insertion_point(field_add:llsf_msgs.MachineInfo.machines)
  return machines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::Machine >&
MachineInfo::machines() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.MachineInfo.machines)
  return machines_;
}

// optional .llsf_msgs.Team team_color = 2;
inline bool MachineInfo::has_team_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInfo::set_has_team_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInfo::clear_has_team_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInfo::clear_team_color() {
  team_color_ = 0;
  clear_has_team_color();
}
inline ::llsf_msgs::Team MachineInfo::team_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.MachineInfo.team_color)
  return static_cast< ::llsf_msgs::Team >(team_color_);
}
inline void MachineInfo::set_team_color(::llsf_msgs::Team value) {
  assert(::llsf_msgs::Team_IsValid(value));
  set_has_team_color();
  team_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.MachineInfo.team_color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace llsf_msgs

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::llsf_msgs::LightSpec_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::LightSpec_CompType>() {
  return ::llsf_msgs::LightSpec_CompType_descriptor();
}
template <> struct is_proto_enum< ::llsf_msgs::ShelfSlotInfo_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::ShelfSlotInfo_CompType>() {
  return ::llsf_msgs::ShelfSlotInfo_CompType_descriptor();
}
template <> struct is_proto_enum< ::llsf_msgs::Machine_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::Machine_CompType>() {
  return ::llsf_msgs::Machine_CompType_descriptor();
}
template <> struct is_proto_enum< ::llsf_msgs::MachineInfo_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::MachineInfo_CompType>() {
  return ::llsf_msgs::MachineInfo_CompType_descriptor();
}
template <> struct is_proto_enum< ::llsf_msgs::ExplorationState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::ExplorationState>() {
  return ::llsf_msgs::ExplorationState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_MachineInfo_2eproto
