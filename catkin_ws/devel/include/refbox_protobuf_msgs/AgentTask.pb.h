// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AgentTask.proto

#ifndef PROTOBUF_INCLUDED_AgentTask_2eproto
#define PROTOBUF_INCLUDED_AgentTask_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Team.pb.h"
#include "ProductColor.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_AgentTask_2eproto 

namespace protobuf_AgentTask_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_AgentTask_2eproto
namespace llsf_msgs {
class AgentTask;
class AgentTaskDefaultTypeInternal;
extern AgentTaskDefaultTypeInternal _AgentTask_default_instance_;
class BufferStation;
class BufferStationDefaultTypeInternal;
extern BufferStationDefaultTypeInternal _BufferStation_default_instance_;
class Deliver;
class DeliverDefaultTypeInternal;
extern DeliverDefaultTypeInternal _Deliver_default_instance_;
class ExploreWaypoint;
class ExploreWaypointDefaultTypeInternal;
extern ExploreWaypointDefaultTypeInternal _ExploreWaypoint_default_instance_;
class Move;
class MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Retrieve;
class RetrieveDefaultTypeInternal;
extern RetrieveDefaultTypeInternal _Retrieve_default_instance_;
class WorkpieceDescription;
class WorkpieceDescriptionDefaultTypeInternal;
extern WorkpieceDescriptionDefaultTypeInternal _WorkpieceDescription_default_instance_;
}  // namespace llsf_msgs
namespace google {
namespace protobuf {
template<> ::llsf_msgs::AgentTask* Arena::CreateMaybeMessage<::llsf_msgs::AgentTask>(Arena*);
template<> ::llsf_msgs::BufferStation* Arena::CreateMaybeMessage<::llsf_msgs::BufferStation>(Arena*);
template<> ::llsf_msgs::Deliver* Arena::CreateMaybeMessage<::llsf_msgs::Deliver>(Arena*);
template<> ::llsf_msgs::ExploreWaypoint* Arena::CreateMaybeMessage<::llsf_msgs::ExploreWaypoint>(Arena*);
template<> ::llsf_msgs::Move* Arena::CreateMaybeMessage<::llsf_msgs::Move>(Arena*);
template<> ::llsf_msgs::Retrieve* Arena::CreateMaybeMessage<::llsf_msgs::Retrieve>(Arena*);
template<> ::llsf_msgs::WorkpieceDescription* Arena::CreateMaybeMessage<::llsf_msgs::WorkpieceDescription>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace llsf_msgs {

enum AgentTask_CompType {
  AgentTask_CompType_COMP_ID = 8000,
  AgentTask_CompType_MSG_TYPE = 502
};
bool AgentTask_CompType_IsValid(int value);
const AgentTask_CompType AgentTask_CompType_CompType_MIN = AgentTask_CompType_MSG_TYPE;
const AgentTask_CompType AgentTask_CompType_CompType_MAX = AgentTask_CompType_COMP_ID;
const int AgentTask_CompType_CompType_ARRAYSIZE = AgentTask_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AgentTask_CompType_descriptor();
inline const ::std::string& AgentTask_CompType_Name(AgentTask_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AgentTask_CompType_descriptor(), value);
}
inline bool AgentTask_CompType_Parse(
    const ::std::string& name, AgentTask_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AgentTask_CompType>(
    AgentTask_CompType_descriptor(), name, value);
}
enum WorkpieceDescription_CompType {
  WorkpieceDescription_CompType_COMP_ID = 8000,
  WorkpieceDescription_CompType_MSG_TYPE = 510
};
bool WorkpieceDescription_CompType_IsValid(int value);
const WorkpieceDescription_CompType WorkpieceDescription_CompType_CompType_MIN = WorkpieceDescription_CompType_MSG_TYPE;
const WorkpieceDescription_CompType WorkpieceDescription_CompType_CompType_MAX = WorkpieceDescription_CompType_COMP_ID;
const int WorkpieceDescription_CompType_CompType_ARRAYSIZE = WorkpieceDescription_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WorkpieceDescription_CompType_descriptor();
inline const ::std::string& WorkpieceDescription_CompType_Name(WorkpieceDescription_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WorkpieceDescription_CompType_descriptor(), value);
}
inline bool WorkpieceDescription_CompType_Parse(
    const ::std::string& name, WorkpieceDescription_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkpieceDescription_CompType>(
    WorkpieceDescription_CompType_descriptor(), name, value);
}
// ===================================================================

class AgentTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.AgentTask) */ {
 public:
  AgentTask();
  virtual ~AgentTask();

  AgentTask(const AgentTask& from);

  inline AgentTask& operator=(const AgentTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AgentTask(AgentTask&& from) noexcept
    : AgentTask() {
    *this = ::std::move(from);
  }

  inline AgentTask& operator=(AgentTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AgentTask* internal_default_instance() {
    return reinterpret_cast<const AgentTask*>(
               &_AgentTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AgentTask* other);
  friend void swap(AgentTask& a, AgentTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AgentTask* New() const final {
    return CreateMaybeMessage<AgentTask>(NULL);
  }

  AgentTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AgentTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AgentTask& from);
  void MergeFrom(const AgentTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AgentTask_CompType CompType;
  static const CompType COMP_ID =
    AgentTask_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    AgentTask_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return AgentTask_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    AgentTask_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    AgentTask_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    AgentTask_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return AgentTask_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return AgentTask_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return AgentTask_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .llsf_msgs.Move move = 4;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 4;
  private:
  const ::llsf_msgs::Move& _internal_move() const;
  public:
  const ::llsf_msgs::Move& move() const;
  ::llsf_msgs::Move* release_move();
  ::llsf_msgs::Move* mutable_move();
  void set_allocated_move(::llsf_msgs::Move* move);

  // optional .llsf_msgs.Retrieve retrieve = 5;
  bool has_retrieve() const;
  void clear_retrieve();
  static const int kRetrieveFieldNumber = 5;
  private:
  const ::llsf_msgs::Retrieve& _internal_retrieve() const;
  public:
  const ::llsf_msgs::Retrieve& retrieve() const;
  ::llsf_msgs::Retrieve* release_retrieve();
  ::llsf_msgs::Retrieve* mutable_retrieve();
  void set_allocated_retrieve(::llsf_msgs::Retrieve* retrieve);

  // optional .llsf_msgs.Deliver deliver = 6;
  bool has_deliver() const;
  void clear_deliver();
  static const int kDeliverFieldNumber = 6;
  private:
  const ::llsf_msgs::Deliver& _internal_deliver() const;
  public:
  const ::llsf_msgs::Deliver& deliver() const;
  ::llsf_msgs::Deliver* release_deliver();
  ::llsf_msgs::Deliver* mutable_deliver();
  void set_allocated_deliver(::llsf_msgs::Deliver* deliver);

  // optional .llsf_msgs.BufferStation buffer = 7;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 7;
  private:
  const ::llsf_msgs::BufferStation& _internal_buffer() const;
  public:
  const ::llsf_msgs::BufferStation& buffer() const;
  ::llsf_msgs::BufferStation* release_buffer();
  ::llsf_msgs::BufferStation* mutable_buffer();
  void set_allocated_buffer(::llsf_msgs::BufferStation* buffer);

  // optional .llsf_msgs.ExploreWaypoint explore_machine = 8;
  bool has_explore_machine() const;
  void clear_explore_machine();
  static const int kExploreMachineFieldNumber = 8;
  private:
  const ::llsf_msgs::ExploreWaypoint& _internal_explore_machine() const;
  public:
  const ::llsf_msgs::ExploreWaypoint& explore_machine() const;
  ::llsf_msgs::ExploreWaypoint* release_explore_machine();
  ::llsf_msgs::ExploreWaypoint* mutable_explore_machine();
  void set_allocated_explore_machine(::llsf_msgs::ExploreWaypoint* explore_machine);

  // optional .llsf_msgs.WorkpieceDescription workpiece_description = 9;
  bool has_workpiece_description() const;
  void clear_workpiece_description();
  static const int kWorkpieceDescriptionFieldNumber = 9;
  private:
  const ::llsf_msgs::WorkpieceDescription& _internal_workpiece_description() const;
  public:
  const ::llsf_msgs::WorkpieceDescription& workpiece_description() const;
  ::llsf_msgs::WorkpieceDescription* release_workpiece_description();
  ::llsf_msgs::WorkpieceDescription* mutable_workpiece_description();
  void set_allocated_workpiece_description(::llsf_msgs::WorkpieceDescription* workpiece_description);

  // required .llsf_msgs.Team team_color = 1;
  bool has_team_color() const;
  void clear_team_color();
  static const int kTeamColorFieldNumber = 1;
  ::llsf_msgs::Team team_color() const;
  void set_team_color(::llsf_msgs::Team value);

  // required uint32 task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  ::google::protobuf::uint32 task_id() const;
  void set_task_id(::google::protobuf::uint32 value);

  // required uint32 robot_id = 3;
  bool has_robot_id() const;
  void clear_robot_id();
  static const int kRobotIdFieldNumber = 3;
  ::google::protobuf::uint32 robot_id() const;
  void set_robot_id(::google::protobuf::uint32 value);

  // optional uint32 order_id = 10;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 10;
  ::google::protobuf::uint32 order_id() const;
  void set_order_id(::google::protobuf::uint32 value);

  // optional bool cancel_task = 11;
  bool has_cancel_task() const;
  void clear_cancel_task();
  static const int kCancelTaskFieldNumber = 11;
  bool cancel_task() const;
  void set_cancel_task(bool value);

  // optional bool pause_task = 12;
  bool has_pause_task() const;
  void clear_pause_task();
  static const int kPauseTaskFieldNumber = 12;
  bool pause_task() const;
  void set_pause_task(bool value);

  // optional bool successful = 13;
  bool has_successful() const;
  void clear_successful();
  static const int kSuccessfulFieldNumber = 13;
  bool successful() const;
  void set_successful(bool value);

  // optional bool canceled = 14;
  bool has_canceled() const;
  void clear_canceled();
  static const int kCanceledFieldNumber = 14;
  bool canceled() const;
  void set_canceled(bool value);

  // optional uint32 error_code = 15;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 15;
  ::google::protobuf::uint32 error_code() const;
  void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.AgentTask)
 private:
  void set_has_team_color();
  void clear_has_team_color();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_robot_id();
  void clear_has_robot_id();
  void set_has_move();
  void clear_has_move();
  void set_has_retrieve();
  void clear_has_retrieve();
  void set_has_deliver();
  void clear_has_deliver();
  void set_has_buffer();
  void clear_has_buffer();
  void set_has_explore_machine();
  void clear_has_explore_machine();
  void set_has_workpiece_description();
  void clear_has_workpiece_description();
  void set_has_order_id();
  void clear_has_order_id();
  void set_has_cancel_task();
  void clear_has_cancel_task();
  void set_has_pause_task();
  void clear_has_pause_task();
  void set_has_successful();
  void clear_has_successful();
  void set_has_canceled();
  void clear_has_canceled();
  void set_has_error_code();
  void clear_has_error_code();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::llsf_msgs::Move* move_;
  ::llsf_msgs::Retrieve* retrieve_;
  ::llsf_msgs::Deliver* deliver_;
  ::llsf_msgs::BufferStation* buffer_;
  ::llsf_msgs::ExploreWaypoint* explore_machine_;
  ::llsf_msgs::WorkpieceDescription* workpiece_description_;
  int team_color_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 robot_id_;
  ::google::protobuf::uint32 order_id_;
  bool cancel_task_;
  bool pause_task_;
  bool successful_;
  bool canceled_;
  ::google::protobuf::uint32 error_code_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.Move) */ {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(Move&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Move& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Move* other);
  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Move* New() const final {
    return CreateMaybeMessage<Move>(NULL);
  }

  Move* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string waypoint = 1;
  bool has_waypoint() const;
  void clear_waypoint();
  static const int kWaypointFieldNumber = 1;
  const ::std::string& waypoint() const;
  void set_waypoint(const ::std::string& value);
  #if LANG_CXX11
  void set_waypoint(::std::string&& value);
  #endif
  void set_waypoint(const char* value);
  void set_waypoint(const char* value, size_t size);
  ::std::string* mutable_waypoint();
  ::std::string* release_waypoint();
  void set_allocated_waypoint(::std::string* waypoint);

  // optional string machine_point = 2;
  bool has_machine_point() const;
  void clear_machine_point();
  static const int kMachinePointFieldNumber = 2;
  const ::std::string& machine_point() const;
  void set_machine_point(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_point(::std::string&& value);
  #endif
  void set_machine_point(const char* value);
  void set_machine_point(const char* value, size_t size);
  ::std::string* mutable_machine_point();
  ::std::string* release_machine_point();
  void set_allocated_machine_point(::std::string* machine_point);

  // @@protoc_insertion_point(class_scope:llsf_msgs.Move)
 private:
  void set_has_waypoint();
  void clear_has_waypoint();
  void set_has_machine_point();
  void clear_has_machine_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr waypoint_;
  ::google::protobuf::internal::ArenaStringPtr machine_point_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Retrieve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.Retrieve) */ {
 public:
  Retrieve();
  virtual ~Retrieve();

  Retrieve(const Retrieve& from);

  inline Retrieve& operator=(const Retrieve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Retrieve(Retrieve&& from) noexcept
    : Retrieve() {
    *this = ::std::move(from);
  }

  inline Retrieve& operator=(Retrieve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Retrieve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Retrieve* internal_default_instance() {
    return reinterpret_cast<const Retrieve*>(
               &_Retrieve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Retrieve* other);
  friend void swap(Retrieve& a, Retrieve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Retrieve* New() const final {
    return CreateMaybeMessage<Retrieve>(NULL);
  }

  Retrieve* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Retrieve>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Retrieve& from);
  void MergeFrom(const Retrieve& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Retrieve* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machine_id = 1;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_id(::std::string&& value);
  #endif
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // required string machine_point = 2;
  bool has_machine_point() const;
  void clear_machine_point();
  static const int kMachinePointFieldNumber = 2;
  const ::std::string& machine_point() const;
  void set_machine_point(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_point(::std::string&& value);
  #endif
  void set_machine_point(const char* value);
  void set_machine_point(const char* value, size_t size);
  ::std::string* mutable_machine_point();
  ::std::string* release_machine_point();
  void set_allocated_machine_point(::std::string* machine_point);

  // @@protoc_insertion_point(class_scope:llsf_msgs.Retrieve)
 private:
  void set_has_machine_id();
  void clear_has_machine_id();
  void set_has_machine_point();
  void clear_has_machine_point();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr machine_point_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Deliver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.Deliver) */ {
 public:
  Deliver();
  virtual ~Deliver();

  Deliver(const Deliver& from);

  inline Deliver& operator=(const Deliver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Deliver(Deliver&& from) noexcept
    : Deliver() {
    *this = ::std::move(from);
  }

  inline Deliver& operator=(Deliver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Deliver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Deliver* internal_default_instance() {
    return reinterpret_cast<const Deliver*>(
               &_Deliver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Deliver* other);
  friend void swap(Deliver& a, Deliver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Deliver* New() const final {
    return CreateMaybeMessage<Deliver>(NULL);
  }

  Deliver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Deliver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Deliver& from);
  void MergeFrom(const Deliver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deliver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machine_id = 1;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_id(::std::string&& value);
  #endif
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // required string machine_point = 2;
  bool has_machine_point() const;
  void clear_machine_point();
  static const int kMachinePointFieldNumber = 2;
  const ::std::string& machine_point() const;
  void set_machine_point(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_point(::std::string&& value);
  #endif
  void set_machine_point(const char* value);
  void set_machine_point(const char* value, size_t size);
  ::std::string* mutable_machine_point();
  ::std::string* release_machine_point();
  void set_allocated_machine_point(::std::string* machine_point);

  // @@protoc_insertion_point(class_scope:llsf_msgs.Deliver)
 private:
  void set_has_machine_id();
  void clear_has_machine_id();
  void set_has_machine_point();
  void clear_has_machine_point();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr machine_point_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferStation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.BufferStation) */ {
 public:
  BufferStation();
  virtual ~BufferStation();

  BufferStation(const BufferStation& from);

  inline BufferStation& operator=(const BufferStation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BufferStation(BufferStation&& from) noexcept
    : BufferStation() {
    *this = ::std::move(from);
  }

  inline BufferStation& operator=(BufferStation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferStation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BufferStation* internal_default_instance() {
    return reinterpret_cast<const BufferStation*>(
               &_BufferStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BufferStation* other);
  friend void swap(BufferStation& a, BufferStation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BufferStation* New() const final {
    return CreateMaybeMessage<BufferStation>(NULL);
  }

  BufferStation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BufferStation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BufferStation& from);
  void MergeFrom(const BufferStation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferStation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machine_id = 1;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_id(::std::string&& value);
  #endif
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // required uint32 shelf_number = 2;
  bool has_shelf_number() const;
  void clear_shelf_number();
  static const int kShelfNumberFieldNumber = 2;
  ::google::protobuf::uint32 shelf_number() const;
  void set_shelf_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.BufferStation)
 private:
  void set_has_machine_id();
  void clear_has_machine_id();
  void set_has_shelf_number();
  void clear_has_shelf_number();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::uint32 shelf_number_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExploreWaypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.ExploreWaypoint) */ {
 public:
  ExploreWaypoint();
  virtual ~ExploreWaypoint();

  ExploreWaypoint(const ExploreWaypoint& from);

  inline ExploreWaypoint& operator=(const ExploreWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExploreWaypoint(ExploreWaypoint&& from) noexcept
    : ExploreWaypoint() {
    *this = ::std::move(from);
  }

  inline ExploreWaypoint& operator=(ExploreWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExploreWaypoint* internal_default_instance() {
    return reinterpret_cast<const ExploreWaypoint*>(
               &_ExploreWaypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ExploreWaypoint* other);
  friend void swap(ExploreWaypoint& a, ExploreWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExploreWaypoint* New() const final {
    return CreateMaybeMessage<ExploreWaypoint>(NULL);
  }

  ExploreWaypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExploreWaypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExploreWaypoint& from);
  void MergeFrom(const ExploreWaypoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExploreWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machine_id = 1;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_id(::std::string&& value);
  #endif
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // required string machine_point = 2;
  bool has_machine_point() const;
  void clear_machine_point();
  static const int kMachinePointFieldNumber = 2;
  const ::std::string& machine_point() const;
  void set_machine_point(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_point(::std::string&& value);
  #endif
  void set_machine_point(const char* value);
  void set_machine_point(const char* value, size_t size);
  ::std::string* mutable_machine_point();
  ::std::string* release_machine_point();
  void set_allocated_machine_point(::std::string* machine_point);

  // required string waypoint = 3;
  bool has_waypoint() const;
  void clear_waypoint();
  static const int kWaypointFieldNumber = 3;
  const ::std::string& waypoint() const;
  void set_waypoint(const ::std::string& value);
  #if LANG_CXX11
  void set_waypoint(::std::string&& value);
  #endif
  void set_waypoint(const char* value);
  void set_waypoint(const char* value, size_t size);
  ::std::string* mutable_waypoint();
  ::std::string* release_waypoint();
  void set_allocated_waypoint(::std::string* waypoint);

  // @@protoc_insertion_point(class_scope:llsf_msgs.ExploreWaypoint)
 private:
  void set_has_machine_id();
  void clear_has_machine_id();
  void set_has_machine_point();
  void clear_has_machine_point();
  void set_has_waypoint();
  void clear_has_waypoint();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr machine_point_;
  ::google::protobuf::internal::ArenaStringPtr waypoint_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkpieceDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.WorkpieceDescription) */ {
 public:
  WorkpieceDescription();
  virtual ~WorkpieceDescription();

  WorkpieceDescription(const WorkpieceDescription& from);

  inline WorkpieceDescription& operator=(const WorkpieceDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkpieceDescription(WorkpieceDescription&& from) noexcept
    : WorkpieceDescription() {
    *this = ::std::move(from);
  }

  inline WorkpieceDescription& operator=(WorkpieceDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkpieceDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkpieceDescription* internal_default_instance() {
    return reinterpret_cast<const WorkpieceDescription*>(
               &_WorkpieceDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WorkpieceDescription* other);
  friend void swap(WorkpieceDescription& a, WorkpieceDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkpieceDescription* New() const final {
    return CreateMaybeMessage<WorkpieceDescription>(NULL);
  }

  WorkpieceDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkpieceDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkpieceDescription& from);
  void MergeFrom(const WorkpieceDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkpieceDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WorkpieceDescription_CompType CompType;
  static const CompType COMP_ID =
    WorkpieceDescription_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    WorkpieceDescription_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return WorkpieceDescription_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    WorkpieceDescription_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    WorkpieceDescription_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    WorkpieceDescription_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return WorkpieceDescription_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return WorkpieceDescription_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return WorkpieceDescription_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .llsf_msgs.RingColor ring_colors = 4;
  int ring_colors_size() const;
  void clear_ring_colors();
  static const int kRingColorsFieldNumber = 4;
  ::llsf_msgs::RingColor ring_colors(int index) const;
  void set_ring_colors(int index, ::llsf_msgs::RingColor value);
  void add_ring_colors(::llsf_msgs::RingColor value);
  const ::google::protobuf::RepeatedField<int>& ring_colors() const;
  ::google::protobuf::RepeatedField<int>* mutable_ring_colors();

  // required .llsf_msgs.BaseColor base_color = 3;
  bool has_base_color() const;
  void clear_base_color();
  static const int kBaseColorFieldNumber = 3;
  ::llsf_msgs::BaseColor base_color() const;
  void set_base_color(::llsf_msgs::BaseColor value);

  // optional .llsf_msgs.CapColor cap_color = 5;
  bool has_cap_color() const;
  void clear_cap_color();
  static const int kCapColorFieldNumber = 5;
  ::llsf_msgs::CapColor cap_color() const;
  void set_cap_color(::llsf_msgs::CapColor value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.WorkpieceDescription)
 private:
  void set_has_base_color();
  void clear_has_base_color();
  void set_has_cap_color();
  void clear_has_cap_color();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> ring_colors_;
  int base_color_;
  int cap_color_;
  friend struct ::protobuf_AgentTask_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AgentTask

// required .llsf_msgs.Team team_color = 1;
inline bool AgentTask::has_team_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AgentTask::set_has_team_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AgentTask::clear_has_team_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AgentTask::clear_team_color() {
  team_color_ = 0;
  clear_has_team_color();
}
inline ::llsf_msgs::Team AgentTask::team_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.team_color)
  return static_cast< ::llsf_msgs::Team >(team_color_);
}
inline void AgentTask::set_team_color(::llsf_msgs::Team value) {
  assert(::llsf_msgs::Team_IsValid(value));
  set_has_team_color();
  team_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.team_color)
}

// required uint32 task_id = 2;
inline bool AgentTask::has_task_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AgentTask::set_has_task_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AgentTask::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AgentTask::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 AgentTask::task_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.task_id)
  return task_id_;
}
inline void AgentTask::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.task_id)
}

// required uint32 robot_id = 3;
inline bool AgentTask::has_robot_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AgentTask::set_has_robot_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AgentTask::clear_has_robot_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AgentTask::clear_robot_id() {
  robot_id_ = 0u;
  clear_has_robot_id();
}
inline ::google::protobuf::uint32 AgentTask::robot_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.robot_id)
  return robot_id_;
}
inline void AgentTask::set_robot_id(::google::protobuf::uint32 value) {
  set_has_robot_id();
  robot_id_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.robot_id)
}

// optional .llsf_msgs.Move move = 4;
inline bool AgentTask::has_move() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTask::set_has_move() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTask::clear_has_move() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTask::clear_move() {
  if (move_ != NULL) move_->Clear();
  clear_has_move();
}
inline const ::llsf_msgs::Move& AgentTask::_internal_move() const {
  return *move_;
}
inline const ::llsf_msgs::Move& AgentTask::move() const {
  const ::llsf_msgs::Move* p = move_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.move)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Move*>(
      &::llsf_msgs::_Move_default_instance_);
}
inline ::llsf_msgs::Move* AgentTask::release_move() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.move)
  clear_has_move();
  ::llsf_msgs::Move* temp = move_;
  move_ = NULL;
  return temp;
}
inline ::llsf_msgs::Move* AgentTask::mutable_move() {
  set_has_move();
  if (move_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Move>(GetArenaNoVirtual());
    move_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.move)
  return move_;
}
inline void AgentTask::set_allocated_move(::llsf_msgs::Move* move) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete move_;
  }
  if (move) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      move = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    set_has_move();
  } else {
    clear_has_move();
  }
  move_ = move;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.move)
}

// optional .llsf_msgs.Retrieve retrieve = 5;
inline bool AgentTask::has_retrieve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTask::set_has_retrieve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTask::clear_has_retrieve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTask::clear_retrieve() {
  if (retrieve_ != NULL) retrieve_->Clear();
  clear_has_retrieve();
}
inline const ::llsf_msgs::Retrieve& AgentTask::_internal_retrieve() const {
  return *retrieve_;
}
inline const ::llsf_msgs::Retrieve& AgentTask::retrieve() const {
  const ::llsf_msgs::Retrieve* p = retrieve_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.retrieve)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Retrieve*>(
      &::llsf_msgs::_Retrieve_default_instance_);
}
inline ::llsf_msgs::Retrieve* AgentTask::release_retrieve() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.retrieve)
  clear_has_retrieve();
  ::llsf_msgs::Retrieve* temp = retrieve_;
  retrieve_ = NULL;
  return temp;
}
inline ::llsf_msgs::Retrieve* AgentTask::mutable_retrieve() {
  set_has_retrieve();
  if (retrieve_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Retrieve>(GetArenaNoVirtual());
    retrieve_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.retrieve)
  return retrieve_;
}
inline void AgentTask::set_allocated_retrieve(::llsf_msgs::Retrieve* retrieve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete retrieve_;
  }
  if (retrieve) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      retrieve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, retrieve, submessage_arena);
    }
    set_has_retrieve();
  } else {
    clear_has_retrieve();
  }
  retrieve_ = retrieve;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.retrieve)
}

// optional .llsf_msgs.Deliver deliver = 6;
inline bool AgentTask::has_deliver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTask::set_has_deliver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTask::clear_has_deliver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTask::clear_deliver() {
  if (deliver_ != NULL) deliver_->Clear();
  clear_has_deliver();
}
inline const ::llsf_msgs::Deliver& AgentTask::_internal_deliver() const {
  return *deliver_;
}
inline const ::llsf_msgs::Deliver& AgentTask::deliver() const {
  const ::llsf_msgs::Deliver* p = deliver_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.deliver)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Deliver*>(
      &::llsf_msgs::_Deliver_default_instance_);
}
inline ::llsf_msgs::Deliver* AgentTask::release_deliver() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.deliver)
  clear_has_deliver();
  ::llsf_msgs::Deliver* temp = deliver_;
  deliver_ = NULL;
  return temp;
}
inline ::llsf_msgs::Deliver* AgentTask::mutable_deliver() {
  set_has_deliver();
  if (deliver_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Deliver>(GetArenaNoVirtual());
    deliver_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.deliver)
  return deliver_;
}
inline void AgentTask::set_allocated_deliver(::llsf_msgs::Deliver* deliver) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete deliver_;
  }
  if (deliver) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deliver = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deliver, submessage_arena);
    }
    set_has_deliver();
  } else {
    clear_has_deliver();
  }
  deliver_ = deliver;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.deliver)
}

// optional .llsf_msgs.BufferStation buffer = 7;
inline bool AgentTask::has_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTask::set_has_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTask::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTask::clear_buffer() {
  if (buffer_ != NULL) buffer_->Clear();
  clear_has_buffer();
}
inline const ::llsf_msgs::BufferStation& AgentTask::_internal_buffer() const {
  return *buffer_;
}
inline const ::llsf_msgs::BufferStation& AgentTask::buffer() const {
  const ::llsf_msgs::BufferStation* p = buffer_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.buffer)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::BufferStation*>(
      &::llsf_msgs::_BufferStation_default_instance_);
}
inline ::llsf_msgs::BufferStation* AgentTask::release_buffer() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.buffer)
  clear_has_buffer();
  ::llsf_msgs::BufferStation* temp = buffer_;
  buffer_ = NULL;
  return temp;
}
inline ::llsf_msgs::BufferStation* AgentTask::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::BufferStation>(GetArenaNoVirtual());
    buffer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.buffer)
  return buffer_;
}
inline void AgentTask::set_allocated_buffer(::llsf_msgs::BufferStation* buffer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete buffer_;
  }
  if (buffer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      buffer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    set_has_buffer();
  } else {
    clear_has_buffer();
  }
  buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.buffer)
}

// optional .llsf_msgs.ExploreWaypoint explore_machine = 8;
inline bool AgentTask::has_explore_machine() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentTask::set_has_explore_machine() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentTask::clear_has_explore_machine() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentTask::clear_explore_machine() {
  if (explore_machine_ != NULL) explore_machine_->Clear();
  clear_has_explore_machine();
}
inline const ::llsf_msgs::ExploreWaypoint& AgentTask::_internal_explore_machine() const {
  return *explore_machine_;
}
inline const ::llsf_msgs::ExploreWaypoint& AgentTask::explore_machine() const {
  const ::llsf_msgs::ExploreWaypoint* p = explore_machine_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.explore_machine)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::ExploreWaypoint*>(
      &::llsf_msgs::_ExploreWaypoint_default_instance_);
}
inline ::llsf_msgs::ExploreWaypoint* AgentTask::release_explore_machine() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.explore_machine)
  clear_has_explore_machine();
  ::llsf_msgs::ExploreWaypoint* temp = explore_machine_;
  explore_machine_ = NULL;
  return temp;
}
inline ::llsf_msgs::ExploreWaypoint* AgentTask::mutable_explore_machine() {
  set_has_explore_machine();
  if (explore_machine_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::ExploreWaypoint>(GetArenaNoVirtual());
    explore_machine_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.explore_machine)
  return explore_machine_;
}
inline void AgentTask::set_allocated_explore_machine(::llsf_msgs::ExploreWaypoint* explore_machine) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete explore_machine_;
  }
  if (explore_machine) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      explore_machine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, explore_machine, submessage_arena);
    }
    set_has_explore_machine();
  } else {
    clear_has_explore_machine();
  }
  explore_machine_ = explore_machine;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.explore_machine)
}

// optional .llsf_msgs.WorkpieceDescription workpiece_description = 9;
inline bool AgentTask::has_workpiece_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentTask::set_has_workpiece_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentTask::clear_has_workpiece_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentTask::clear_workpiece_description() {
  if (workpiece_description_ != NULL) workpiece_description_->Clear();
  clear_has_workpiece_description();
}
inline const ::llsf_msgs::WorkpieceDescription& AgentTask::_internal_workpiece_description() const {
  return *workpiece_description_;
}
inline const ::llsf_msgs::WorkpieceDescription& AgentTask::workpiece_description() const {
  const ::llsf_msgs::WorkpieceDescription* p = workpiece_description_;
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.workpiece_description)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::WorkpieceDescription*>(
      &::llsf_msgs::_WorkpieceDescription_default_instance_);
}
inline ::llsf_msgs::WorkpieceDescription* AgentTask::release_workpiece_description() {
  // @@protoc_insertion_point(field_release:llsf_msgs.AgentTask.workpiece_description)
  clear_has_workpiece_description();
  ::llsf_msgs::WorkpieceDescription* temp = workpiece_description_;
  workpiece_description_ = NULL;
  return temp;
}
inline ::llsf_msgs::WorkpieceDescription* AgentTask::mutable_workpiece_description() {
  set_has_workpiece_description();
  if (workpiece_description_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::WorkpieceDescription>(GetArenaNoVirtual());
    workpiece_description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.AgentTask.workpiece_description)
  return workpiece_description_;
}
inline void AgentTask::set_allocated_workpiece_description(::llsf_msgs::WorkpieceDescription* workpiece_description) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete workpiece_description_;
  }
  if (workpiece_description) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      workpiece_description = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workpiece_description, submessage_arena);
    }
    set_has_workpiece_description();
  } else {
    clear_has_workpiece_description();
  }
  workpiece_description_ = workpiece_description;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.AgentTask.workpiece_description)
}

// optional uint32 order_id = 10;
inline bool AgentTask::has_order_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AgentTask::set_has_order_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AgentTask::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AgentTask::clear_order_id() {
  order_id_ = 0u;
  clear_has_order_id();
}
inline ::google::protobuf::uint32 AgentTask::order_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.order_id)
  return order_id_;
}
inline void AgentTask::set_order_id(::google::protobuf::uint32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.order_id)
}

// optional bool cancel_task = 11;
inline bool AgentTask::has_cancel_task() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AgentTask::set_has_cancel_task() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AgentTask::clear_has_cancel_task() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AgentTask::clear_cancel_task() {
  cancel_task_ = false;
  clear_has_cancel_task();
}
inline bool AgentTask::cancel_task() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.cancel_task)
  return cancel_task_;
}
inline void AgentTask::set_cancel_task(bool value) {
  set_has_cancel_task();
  cancel_task_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.cancel_task)
}

// optional bool pause_task = 12;
inline bool AgentTask::has_pause_task() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AgentTask::set_has_pause_task() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AgentTask::clear_has_pause_task() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AgentTask::clear_pause_task() {
  pause_task_ = false;
  clear_has_pause_task();
}
inline bool AgentTask::pause_task() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.pause_task)
  return pause_task_;
}
inline void AgentTask::set_pause_task(bool value) {
  set_has_pause_task();
  pause_task_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.pause_task)
}

// optional bool successful = 13;
inline bool AgentTask::has_successful() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AgentTask::set_has_successful() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AgentTask::clear_has_successful() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AgentTask::clear_successful() {
  successful_ = false;
  clear_has_successful();
}
inline bool AgentTask::successful() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.successful)
  return successful_;
}
inline void AgentTask::set_successful(bool value) {
  set_has_successful();
  successful_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.successful)
}

// optional bool canceled = 14;
inline bool AgentTask::has_canceled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AgentTask::set_has_canceled() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AgentTask::clear_has_canceled() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AgentTask::clear_canceled() {
  canceled_ = false;
  clear_has_canceled();
}
inline bool AgentTask::canceled() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.canceled)
  return canceled_;
}
inline void AgentTask::set_canceled(bool value) {
  set_has_canceled();
  canceled_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.canceled)
}

// optional uint32 error_code = 15;
inline bool AgentTask::has_error_code() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AgentTask::set_has_error_code() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AgentTask::clear_has_error_code() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AgentTask::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 AgentTask::error_code() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.AgentTask.error_code)
  return error_code_;
}
inline void AgentTask::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.AgentTask.error_code)
}

// -------------------------------------------------------------------

// Move

// required string waypoint = 1;
inline bool Move::has_waypoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move::set_has_waypoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move::clear_has_waypoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move::clear_waypoint() {
  waypoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_waypoint();
}
inline const ::std::string& Move::waypoint() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Move.waypoint)
  return waypoint_.GetNoArena();
}
inline void Move::set_waypoint(const ::std::string& value) {
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Move.waypoint)
}
#if LANG_CXX11
inline void Move::set_waypoint(::std::string&& value) {
  set_has_waypoint();
  waypoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Move.waypoint)
}
#endif
inline void Move::set_waypoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Move.waypoint)
}
inline void Move::set_waypoint(const char* value, size_t size) {
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Move.waypoint)
}
inline ::std::string* Move::mutable_waypoint() {
  set_has_waypoint();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Move.waypoint)
  return waypoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Move::release_waypoint() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Move.waypoint)
  if (!has_waypoint()) {
    return NULL;
  }
  clear_has_waypoint();
  return waypoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Move::set_allocated_waypoint(::std::string* waypoint) {
  if (waypoint != NULL) {
    set_has_waypoint();
  } else {
    clear_has_waypoint();
  }
  waypoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), waypoint);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Move.waypoint)
}

// optional string machine_point = 2;
inline bool Move::has_machine_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move::set_has_machine_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move::clear_has_machine_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move::clear_machine_point() {
  machine_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_point();
}
inline const ::std::string& Move::machine_point() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Move.machine_point)
  return machine_point_.GetNoArena();
}
inline void Move::set_machine_point(const ::std::string& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Move.machine_point)
}
#if LANG_CXX11
inline void Move::set_machine_point(::std::string&& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Move.machine_point)
}
#endif
inline void Move::set_machine_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Move.machine_point)
}
inline void Move::set_machine_point(const char* value, size_t size) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Move.machine_point)
}
inline ::std::string* Move::mutable_machine_point() {
  set_has_machine_point();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Move.machine_point)
  return machine_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Move::release_machine_point() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Move.machine_point)
  if (!has_machine_point()) {
    return NULL;
  }
  clear_has_machine_point();
  return machine_point_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Move::set_allocated_machine_point(::std::string* machine_point) {
  if (machine_point != NULL) {
    set_has_machine_point();
  } else {
    clear_has_machine_point();
  }
  machine_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_point);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Move.machine_point)
}

// -------------------------------------------------------------------

// Retrieve

// required string machine_id = 1;
inline bool Retrieve::has_machine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Retrieve::set_has_machine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Retrieve::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Retrieve::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& Retrieve::machine_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Retrieve.machine_id)
  return machine_id_.GetNoArena();
}
inline void Retrieve::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Retrieve.machine_id)
}
#if LANG_CXX11
inline void Retrieve::set_machine_id(::std::string&& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Retrieve.machine_id)
}
#endif
inline void Retrieve::set_machine_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Retrieve.machine_id)
}
inline void Retrieve::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Retrieve.machine_id)
}
inline ::std::string* Retrieve::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Retrieve.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Retrieve::release_machine_id() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Retrieve.machine_id)
  if (!has_machine_id()) {
    return NULL;
  }
  clear_has_machine_id();
  return machine_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Retrieve::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Retrieve.machine_id)
}

// required string machine_point = 2;
inline bool Retrieve::has_machine_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Retrieve::set_has_machine_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Retrieve::clear_has_machine_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Retrieve::clear_machine_point() {
  machine_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_point();
}
inline const ::std::string& Retrieve::machine_point() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Retrieve.machine_point)
  return machine_point_.GetNoArena();
}
inline void Retrieve::set_machine_point(const ::std::string& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Retrieve.machine_point)
}
#if LANG_CXX11
inline void Retrieve::set_machine_point(::std::string&& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Retrieve.machine_point)
}
#endif
inline void Retrieve::set_machine_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Retrieve.machine_point)
}
inline void Retrieve::set_machine_point(const char* value, size_t size) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Retrieve.machine_point)
}
inline ::std::string* Retrieve::mutable_machine_point() {
  set_has_machine_point();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Retrieve.machine_point)
  return machine_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Retrieve::release_machine_point() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Retrieve.machine_point)
  if (!has_machine_point()) {
    return NULL;
  }
  clear_has_machine_point();
  return machine_point_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Retrieve::set_allocated_machine_point(::std::string* machine_point) {
  if (machine_point != NULL) {
    set_has_machine_point();
  } else {
    clear_has_machine_point();
  }
  machine_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_point);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Retrieve.machine_point)
}

// -------------------------------------------------------------------

// Deliver

// required string machine_id = 1;
inline bool Deliver::has_machine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Deliver::set_has_machine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Deliver::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Deliver::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& Deliver::machine_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Deliver.machine_id)
  return machine_id_.GetNoArena();
}
inline void Deliver::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Deliver.machine_id)
}
#if LANG_CXX11
inline void Deliver::set_machine_id(::std::string&& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Deliver.machine_id)
}
#endif
inline void Deliver::set_machine_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Deliver.machine_id)
}
inline void Deliver::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Deliver.machine_id)
}
inline ::std::string* Deliver::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Deliver.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deliver::release_machine_id() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Deliver.machine_id)
  if (!has_machine_id()) {
    return NULL;
  }
  clear_has_machine_id();
  return machine_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deliver::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Deliver.machine_id)
}

// required string machine_point = 2;
inline bool Deliver::has_machine_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Deliver::set_has_machine_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Deliver::clear_has_machine_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Deliver::clear_machine_point() {
  machine_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_point();
}
inline const ::std::string& Deliver::machine_point() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.Deliver.machine_point)
  return machine_point_.GetNoArena();
}
inline void Deliver::set_machine_point(const ::std::string& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.Deliver.machine_point)
}
#if LANG_CXX11
inline void Deliver::set_machine_point(::std::string&& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.Deliver.machine_point)
}
#endif
inline void Deliver::set_machine_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.Deliver.machine_point)
}
inline void Deliver::set_machine_point(const char* value, size_t size) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.Deliver.machine_point)
}
inline ::std::string* Deliver::mutable_machine_point() {
  set_has_machine_point();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.Deliver.machine_point)
  return machine_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deliver::release_machine_point() {
  // @@protoc_insertion_point(field_release:llsf_msgs.Deliver.machine_point)
  if (!has_machine_point()) {
    return NULL;
  }
  clear_has_machine_point();
  return machine_point_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deliver::set_allocated_machine_point(::std::string* machine_point) {
  if (machine_point != NULL) {
    set_has_machine_point();
  } else {
    clear_has_machine_point();
  }
  machine_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_point);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.Deliver.machine_point)
}

// -------------------------------------------------------------------

// BufferStation

// required string machine_id = 1;
inline bool BufferStation::has_machine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BufferStation::set_has_machine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BufferStation::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BufferStation::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& BufferStation::machine_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BufferStation.machine_id)
  return machine_id_.GetNoArena();
}
inline void BufferStation::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.BufferStation.machine_id)
}
#if LANG_CXX11
inline void BufferStation::set_machine_id(::std::string&& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.BufferStation.machine_id)
}
#endif
inline void BufferStation::set_machine_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.BufferStation.machine_id)
}
inline void BufferStation::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.BufferStation.machine_id)
}
inline ::std::string* BufferStation::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BufferStation.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BufferStation::release_machine_id() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BufferStation.machine_id)
  if (!has_machine_id()) {
    return NULL;
  }
  clear_has_machine_id();
  return machine_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BufferStation::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BufferStation.machine_id)
}

// required uint32 shelf_number = 2;
inline bool BufferStation::has_shelf_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BufferStation::set_has_shelf_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BufferStation::clear_has_shelf_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BufferStation::clear_shelf_number() {
  shelf_number_ = 0u;
  clear_has_shelf_number();
}
inline ::google::protobuf::uint32 BufferStation::shelf_number() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BufferStation.shelf_number)
  return shelf_number_;
}
inline void BufferStation::set_shelf_number(::google::protobuf::uint32 value) {
  set_has_shelf_number();
  shelf_number_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.BufferStation.shelf_number)
}

// -------------------------------------------------------------------

// ExploreWaypoint

// required string machine_id = 1;
inline bool ExploreWaypoint::has_machine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExploreWaypoint::set_has_machine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExploreWaypoint::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExploreWaypoint::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& ExploreWaypoint::machine_id() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ExploreWaypoint.machine_id)
  return machine_id_.GetNoArena();
}
inline void ExploreWaypoint::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.ExploreWaypoint.machine_id)
}
#if LANG_CXX11
inline void ExploreWaypoint::set_machine_id(::std::string&& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.ExploreWaypoint.machine_id)
}
#endif
inline void ExploreWaypoint::set_machine_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.ExploreWaypoint.machine_id)
}
inline void ExploreWaypoint::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.ExploreWaypoint.machine_id)
}
inline ::std::string* ExploreWaypoint::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.ExploreWaypoint.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExploreWaypoint::release_machine_id() {
  // @@protoc_insertion_point(field_release:llsf_msgs.ExploreWaypoint.machine_id)
  if (!has_machine_id()) {
    return NULL;
  }
  clear_has_machine_id();
  return machine_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExploreWaypoint::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.ExploreWaypoint.machine_id)
}

// required string machine_point = 2;
inline bool ExploreWaypoint::has_machine_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExploreWaypoint::set_has_machine_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExploreWaypoint::clear_has_machine_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExploreWaypoint::clear_machine_point() {
  machine_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_point();
}
inline const ::std::string& ExploreWaypoint::machine_point() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ExploreWaypoint.machine_point)
  return machine_point_.GetNoArena();
}
inline void ExploreWaypoint::set_machine_point(const ::std::string& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.ExploreWaypoint.machine_point)
}
#if LANG_CXX11
inline void ExploreWaypoint::set_machine_point(::std::string&& value) {
  set_has_machine_point();
  machine_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.ExploreWaypoint.machine_point)
}
#endif
inline void ExploreWaypoint::set_machine_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.ExploreWaypoint.machine_point)
}
inline void ExploreWaypoint::set_machine_point(const char* value, size_t size) {
  set_has_machine_point();
  machine_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.ExploreWaypoint.machine_point)
}
inline ::std::string* ExploreWaypoint::mutable_machine_point() {
  set_has_machine_point();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.ExploreWaypoint.machine_point)
  return machine_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExploreWaypoint::release_machine_point() {
  // @@protoc_insertion_point(field_release:llsf_msgs.ExploreWaypoint.machine_point)
  if (!has_machine_point()) {
    return NULL;
  }
  clear_has_machine_point();
  return machine_point_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExploreWaypoint::set_allocated_machine_point(::std::string* machine_point) {
  if (machine_point != NULL) {
    set_has_machine_point();
  } else {
    clear_has_machine_point();
  }
  machine_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_point);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.ExploreWaypoint.machine_point)
}

// required string waypoint = 3;
inline bool ExploreWaypoint::has_waypoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExploreWaypoint::set_has_waypoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExploreWaypoint::clear_has_waypoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExploreWaypoint::clear_waypoint() {
  waypoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_waypoint();
}
inline const ::std::string& ExploreWaypoint::waypoint() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.ExploreWaypoint.waypoint)
  return waypoint_.GetNoArena();
}
inline void ExploreWaypoint::set_waypoint(const ::std::string& value) {
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.ExploreWaypoint.waypoint)
}
#if LANG_CXX11
inline void ExploreWaypoint::set_waypoint(::std::string&& value) {
  set_has_waypoint();
  waypoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.ExploreWaypoint.waypoint)
}
#endif
inline void ExploreWaypoint::set_waypoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.ExploreWaypoint.waypoint)
}
inline void ExploreWaypoint::set_waypoint(const char* value, size_t size) {
  set_has_waypoint();
  waypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.ExploreWaypoint.waypoint)
}
inline ::std::string* ExploreWaypoint::mutable_waypoint() {
  set_has_waypoint();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.ExploreWaypoint.waypoint)
  return waypoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExploreWaypoint::release_waypoint() {
  // @@protoc_insertion_point(field_release:llsf_msgs.ExploreWaypoint.waypoint)
  if (!has_waypoint()) {
    return NULL;
  }
  clear_has_waypoint();
  return waypoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExploreWaypoint::set_allocated_waypoint(::std::string* waypoint) {
  if (waypoint != NULL) {
    set_has_waypoint();
  } else {
    clear_has_waypoint();
  }
  waypoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), waypoint);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.ExploreWaypoint.waypoint)
}

// -------------------------------------------------------------------

// WorkpieceDescription

// required .llsf_msgs.BaseColor base_color = 3;
inline bool WorkpieceDescription::has_base_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkpieceDescription::set_has_base_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkpieceDescription::clear_has_base_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkpieceDescription::clear_base_color() {
  base_color_ = 1;
  clear_has_base_color();
}
inline ::llsf_msgs::BaseColor WorkpieceDescription::base_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.WorkpieceDescription.base_color)
  return static_cast< ::llsf_msgs::BaseColor >(base_color_);
}
inline void WorkpieceDescription::set_base_color(::llsf_msgs::BaseColor value) {
  assert(::llsf_msgs::BaseColor_IsValid(value));
  set_has_base_color();
  base_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.WorkpieceDescription.base_color)
}

// repeated .llsf_msgs.RingColor ring_colors = 4;
inline int WorkpieceDescription::ring_colors_size() const {
  return ring_colors_.size();
}
inline void WorkpieceDescription::clear_ring_colors() {
  ring_colors_.Clear();
}
inline ::llsf_msgs::RingColor WorkpieceDescription::ring_colors(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.WorkpieceDescription.ring_colors)
  return static_cast< ::llsf_msgs::RingColor >(ring_colors_.Get(index));
}
inline void WorkpieceDescription::set_ring_colors(int index, ::llsf_msgs::RingColor value) {
  assert(::llsf_msgs::RingColor_IsValid(value));
  ring_colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:llsf_msgs.WorkpieceDescription.ring_colors)
}
inline void WorkpieceDescription::add_ring_colors(::llsf_msgs::RingColor value) {
  assert(::llsf_msgs::RingColor_IsValid(value));
  ring_colors_.Add(value);
  // @@protoc_insertion_point(field_add:llsf_msgs.WorkpieceDescription.ring_colors)
}
inline const ::google::protobuf::RepeatedField<int>&
WorkpieceDescription::ring_colors() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.WorkpieceDescription.ring_colors)
  return ring_colors_;
}
inline ::google::protobuf::RepeatedField<int>*
WorkpieceDescription::mutable_ring_colors() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.WorkpieceDescription.ring_colors)
  return &ring_colors_;
}

// optional .llsf_msgs.CapColor cap_color = 5;
inline bool WorkpieceDescription::has_cap_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkpieceDescription::set_has_cap_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkpieceDescription::clear_has_cap_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkpieceDescription::clear_cap_color() {
  cap_color_ = 1;
  clear_has_cap_color();
}
inline ::llsf_msgs::CapColor WorkpieceDescription::cap_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.WorkpieceDescription.cap_color)
  return static_cast< ::llsf_msgs::CapColor >(cap_color_);
}
inline void WorkpieceDescription::set_cap_color(::llsf_msgs::CapColor value) {
  assert(::llsf_msgs::CapColor_IsValid(value));
  set_has_cap_color();
  cap_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.WorkpieceDescription.cap_color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace llsf_msgs

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::llsf_msgs::AgentTask_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::AgentTask_CompType>() {
  return ::llsf_msgs::AgentTask_CompType_descriptor();
}
template <> struct is_proto_enum< ::llsf_msgs::WorkpieceDescription_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::WorkpieceDescription_CompType>() {
  return ::llsf_msgs::WorkpieceDescription_CompType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_AgentTask_2eproto
