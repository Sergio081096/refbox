// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BeaconSignal.proto

#ifndef PROTOBUF_INCLUDED_BeaconSignal_2eproto
#define PROTOBUF_INCLUDED_BeaconSignal_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Time.pb.h"
#include "Team.pb.h"
#include "Pose2D.pb.h"
#include "AgentTask.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BeaconSignal_2eproto 

namespace protobuf_BeaconSignal_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BeaconSignal_2eproto
namespace llsf_msgs {
class BeaconSignal;
class BeaconSignalDefaultTypeInternal;
extern BeaconSignalDefaultTypeInternal _BeaconSignal_default_instance_;
class FinishedTask;
class FinishedTaskDefaultTypeInternal;
extern FinishedTaskDefaultTypeInternal _FinishedTask_default_instance_;
}  // namespace llsf_msgs
namespace google {
namespace protobuf {
template<> ::llsf_msgs::BeaconSignal* Arena::CreateMaybeMessage<::llsf_msgs::BeaconSignal>(Arena*);
template<> ::llsf_msgs::FinishedTask* Arena::CreateMaybeMessage<::llsf_msgs::FinishedTask>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace llsf_msgs {

enum BeaconSignal_CompType {
  BeaconSignal_CompType_COMP_ID = 2000,
  BeaconSignal_CompType_MSG_TYPE = 1
};
bool BeaconSignal_CompType_IsValid(int value);
const BeaconSignal_CompType BeaconSignal_CompType_CompType_MIN = BeaconSignal_CompType_MSG_TYPE;
const BeaconSignal_CompType BeaconSignal_CompType_CompType_MAX = BeaconSignal_CompType_COMP_ID;
const int BeaconSignal_CompType_CompType_ARRAYSIZE = BeaconSignal_CompType_CompType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BeaconSignal_CompType_descriptor();
inline const ::std::string& BeaconSignal_CompType_Name(BeaconSignal_CompType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BeaconSignal_CompType_descriptor(), value);
}
inline bool BeaconSignal_CompType_Parse(
    const ::std::string& name, BeaconSignal_CompType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BeaconSignal_CompType>(
    BeaconSignal_CompType_descriptor(), name, value);
}
// ===================================================================

class BeaconSignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.BeaconSignal) */ {
 public:
  BeaconSignal();
  virtual ~BeaconSignal();

  BeaconSignal(const BeaconSignal& from);

  inline BeaconSignal& operator=(const BeaconSignal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BeaconSignal(BeaconSignal&& from) noexcept
    : BeaconSignal() {
    *this = ::std::move(from);
  }

  inline BeaconSignal& operator=(BeaconSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BeaconSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BeaconSignal* internal_default_instance() {
    return reinterpret_cast<const BeaconSignal*>(
               &_BeaconSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BeaconSignal* other);
  friend void swap(BeaconSignal& a, BeaconSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BeaconSignal* New() const final {
    return CreateMaybeMessage<BeaconSignal>(NULL);
  }

  BeaconSignal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BeaconSignal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BeaconSignal& from);
  void MergeFrom(const BeaconSignal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeaconSignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BeaconSignal_CompType CompType;
  static const CompType COMP_ID =
    BeaconSignal_CompType_COMP_ID;
  static const CompType MSG_TYPE =
    BeaconSignal_CompType_MSG_TYPE;
  static inline bool CompType_IsValid(int value) {
    return BeaconSignal_CompType_IsValid(value);
  }
  static const CompType CompType_MIN =
    BeaconSignal_CompType_CompType_MIN;
  static const CompType CompType_MAX =
    BeaconSignal_CompType_CompType_MAX;
  static const int CompType_ARRAYSIZE =
    BeaconSignal_CompType_CompType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompType_descriptor() {
    return BeaconSignal_CompType_descriptor();
  }
  static inline const ::std::string& CompType_Name(CompType value) {
    return BeaconSignal_CompType_Name(value);
  }
  static inline bool CompType_Parse(const ::std::string& name,
      CompType* value) {
    return BeaconSignal_CompType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .llsf_msgs.FinishedTask finished_tasks = 10;
  int finished_tasks_size() const;
  void clear_finished_tasks();
  static const int kFinishedTasksFieldNumber = 10;
  ::llsf_msgs::FinishedTask* mutable_finished_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::FinishedTask >*
      mutable_finished_tasks();
  const ::llsf_msgs::FinishedTask& finished_tasks(int index) const;
  ::llsf_msgs::FinishedTask* add_finished_tasks();
  const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::FinishedTask >&
      finished_tasks() const;

  // required string team_name = 4;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // required string peer_name = 5;
  bool has_peer_name() const;
  void clear_peer_name();
  static const int kPeerNameFieldNumber = 5;
  const ::std::string& peer_name() const;
  void set_peer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_name(::std::string&& value);
  #endif
  void set_peer_name(const char* value);
  void set_peer_name(const char* value, size_t size);
  ::std::string* mutable_peer_name();
  ::std::string* release_peer_name();
  void set_allocated_peer_name(::std::string* peer_name);

  // required .llsf_msgs.Time time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  private:
  const ::llsf_msgs::Time& _internal_time() const;
  public:
  const ::llsf_msgs::Time& time() const;
  ::llsf_msgs::Time* release_time();
  ::llsf_msgs::Time* mutable_time();
  void set_allocated_time(::llsf_msgs::Time* time);

  // optional .llsf_msgs.Pose2D pose = 7;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 7;
  private:
  const ::llsf_msgs::Pose2D& _internal_pose() const;
  public:
  const ::llsf_msgs::Pose2D& pose() const;
  ::llsf_msgs::Pose2D* release_pose();
  ::llsf_msgs::Pose2D* mutable_pose();
  void set_allocated_pose(::llsf_msgs::Pose2D* pose);

  // optional .llsf_msgs.AgentTask task = 9;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 9;
  private:
  const ::llsf_msgs::AgentTask& _internal_task() const;
  public:
  const ::llsf_msgs::AgentTask& task() const;
  ::llsf_msgs::AgentTask* release_task();
  ::llsf_msgs::AgentTask* mutable_task();
  void set_allocated_task(::llsf_msgs::AgentTask* task);

  // required uint64 seq = 2;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::uint64 seq() const;
  void set_seq(::google::protobuf::uint64 value);

  // optional .llsf_msgs.Team team_color = 6;
  bool has_team_color() const;
  void clear_team_color();
  static const int kTeamColorFieldNumber = 6;
  ::llsf_msgs::Team team_color() const;
  void set_team_color(::llsf_msgs::Team value);

  // required uint32 number = 8;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 8;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.BeaconSignal)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_seq();
  void clear_has_seq();
  void set_has_number();
  void clear_has_number();
  void set_has_team_name();
  void clear_has_team_name();
  void set_has_peer_name();
  void clear_has_peer_name();
  void set_has_team_color();
  void clear_has_team_color();
  void set_has_pose();
  void clear_has_pose();
  void set_has_task();
  void clear_has_task();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::llsf_msgs::FinishedTask > finished_tasks_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::internal::ArenaStringPtr peer_name_;
  ::llsf_msgs::Time* time_;
  ::llsf_msgs::Pose2D* pose_;
  ::llsf_msgs::AgentTask* task_;
  ::google::protobuf::uint64 seq_;
  int team_color_;
  ::google::protobuf::uint32 number_;
  friend struct ::protobuf_BeaconSignal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinishedTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:llsf_msgs.FinishedTask) */ {
 public:
  FinishedTask();
  virtual ~FinishedTask();

  FinishedTask(const FinishedTask& from);

  inline FinishedTask& operator=(const FinishedTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinishedTask(FinishedTask&& from) noexcept
    : FinishedTask() {
    *this = ::std::move(from);
  }

  inline FinishedTask& operator=(FinishedTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishedTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishedTask* internal_default_instance() {
    return reinterpret_cast<const FinishedTask*>(
               &_FinishedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FinishedTask* other);
  friend void swap(FinishedTask& a, FinishedTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishedTask* New() const final {
    return CreateMaybeMessage<FinishedTask>(NULL);
  }

  FinishedTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FinishedTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FinishedTask& from);
  void MergeFrom(const FinishedTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishedTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TaskId = 1;
  bool has_taskid() const;
  void clear_taskid();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::uint32 taskid() const;
  void set_taskid(::google::protobuf::uint32 value);

  // required bool successful = 2;
  bool has_successful() const;
  void clear_successful();
  static const int kSuccessfulFieldNumber = 2;
  bool successful() const;
  void set_successful(bool value);

  // @@protoc_insertion_point(class_scope:llsf_msgs.FinishedTask)
 private:
  void set_has_taskid();
  void clear_has_taskid();
  void set_has_successful();
  void clear_has_successful();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 taskid_;
  bool successful_;
  friend struct ::protobuf_BeaconSignal_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BeaconSignal

// required .llsf_msgs.Time time = 1;
inline bool BeaconSignal::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BeaconSignal::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BeaconSignal::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::llsf_msgs::Time& BeaconSignal::_internal_time() const {
  return *time_;
}
inline const ::llsf_msgs::Time& BeaconSignal::time() const {
  const ::llsf_msgs::Time* p = time_;
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.time)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Time*>(
      &::llsf_msgs::_Time_default_instance_);
}
inline ::llsf_msgs::Time* BeaconSignal::release_time() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BeaconSignal.time)
  clear_has_time();
  ::llsf_msgs::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::llsf_msgs::Time* BeaconSignal::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Time>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.time)
  return time_;
}
inline void BeaconSignal::set_allocated_time(::llsf_msgs::Time* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    set_has_time();
  } else {
    clear_has_time();
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BeaconSignal.time)
}

// required uint64 seq = 2;
inline bool BeaconSignal::has_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BeaconSignal::set_has_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BeaconSignal::clear_has_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BeaconSignal::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 BeaconSignal::seq() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.seq)
  return seq_;
}
inline void BeaconSignal::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.BeaconSignal.seq)
}

// required uint32 number = 8;
inline bool BeaconSignal::has_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BeaconSignal::set_has_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BeaconSignal::clear_has_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BeaconSignal::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 BeaconSignal::number() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.number)
  return number_;
}
inline void BeaconSignal::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.BeaconSignal.number)
}

// required string team_name = 4;
inline bool BeaconSignal::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeaconSignal::set_has_team_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeaconSignal::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeaconSignal::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_team_name();
}
inline const ::std::string& BeaconSignal::team_name() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.team_name)
  return team_name_.GetNoArena();
}
inline void BeaconSignal::set_team_name(const ::std::string& value) {
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.BeaconSignal.team_name)
}
#if LANG_CXX11
inline void BeaconSignal::set_team_name(::std::string&& value) {
  set_has_team_name();
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.BeaconSignal.team_name)
}
#endif
inline void BeaconSignal::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.BeaconSignal.team_name)
}
inline void BeaconSignal::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.BeaconSignal.team_name)
}
inline ::std::string* BeaconSignal::mutable_team_name() {
  set_has_team_name();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BeaconSignal::release_team_name() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BeaconSignal.team_name)
  if (!has_team_name()) {
    return NULL;
  }
  clear_has_team_name();
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BeaconSignal::set_allocated_team_name(::std::string* team_name) {
  if (team_name != NULL) {
    set_has_team_name();
  } else {
    clear_has_team_name();
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BeaconSignal.team_name)
}

// required string peer_name = 5;
inline bool BeaconSignal::has_peer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BeaconSignal::set_has_peer_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BeaconSignal::clear_has_peer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BeaconSignal::clear_peer_name() {
  peer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_name();
}
inline const ::std::string& BeaconSignal::peer_name() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.peer_name)
  return peer_name_.GetNoArena();
}
inline void BeaconSignal::set_peer_name(const ::std::string& value) {
  set_has_peer_name();
  peer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:llsf_msgs.BeaconSignal.peer_name)
}
#if LANG_CXX11
inline void BeaconSignal::set_peer_name(::std::string&& value) {
  set_has_peer_name();
  peer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:llsf_msgs.BeaconSignal.peer_name)
}
#endif
inline void BeaconSignal::set_peer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_name();
  peer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:llsf_msgs.BeaconSignal.peer_name)
}
inline void BeaconSignal::set_peer_name(const char* value, size_t size) {
  set_has_peer_name();
  peer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:llsf_msgs.BeaconSignal.peer_name)
}
inline ::std::string* BeaconSignal::mutable_peer_name() {
  set_has_peer_name();
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.peer_name)
  return peer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BeaconSignal::release_peer_name() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BeaconSignal.peer_name)
  if (!has_peer_name()) {
    return NULL;
  }
  clear_has_peer_name();
  return peer_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BeaconSignal::set_allocated_peer_name(::std::string* peer_name) {
  if (peer_name != NULL) {
    set_has_peer_name();
  } else {
    clear_has_peer_name();
  }
  peer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_name);
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BeaconSignal.peer_name)
}

// optional .llsf_msgs.Team team_color = 6;
inline bool BeaconSignal::has_team_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BeaconSignal::set_has_team_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BeaconSignal::clear_has_team_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BeaconSignal::clear_team_color() {
  team_color_ = 0;
  clear_has_team_color();
}
inline ::llsf_msgs::Team BeaconSignal::team_color() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.team_color)
  return static_cast< ::llsf_msgs::Team >(team_color_);
}
inline void BeaconSignal::set_team_color(::llsf_msgs::Team value) {
  assert(::llsf_msgs::Team_IsValid(value));
  set_has_team_color();
  team_color_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.BeaconSignal.team_color)
}

// optional .llsf_msgs.Pose2D pose = 7;
inline bool BeaconSignal::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BeaconSignal::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BeaconSignal::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::llsf_msgs::Pose2D& BeaconSignal::_internal_pose() const {
  return *pose_;
}
inline const ::llsf_msgs::Pose2D& BeaconSignal::pose() const {
  const ::llsf_msgs::Pose2D* p = pose_;
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::Pose2D*>(
      &::llsf_msgs::_Pose2D_default_instance_);
}
inline ::llsf_msgs::Pose2D* BeaconSignal::release_pose() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BeaconSignal.pose)
  clear_has_pose();
  ::llsf_msgs::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::llsf_msgs::Pose2D* BeaconSignal::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::Pose2D>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.pose)
  return pose_;
}
inline void BeaconSignal::set_allocated_pose(::llsf_msgs::Pose2D* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BeaconSignal.pose)
}

// optional .llsf_msgs.AgentTask task = 9;
inline bool BeaconSignal::has_task() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BeaconSignal::set_has_task() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BeaconSignal::clear_has_task() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::llsf_msgs::AgentTask& BeaconSignal::_internal_task() const {
  return *task_;
}
inline const ::llsf_msgs::AgentTask& BeaconSignal::task() const {
  const ::llsf_msgs::AgentTask* p = task_;
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.task)
  return p != NULL ? *p : *reinterpret_cast<const ::llsf_msgs::AgentTask*>(
      &::llsf_msgs::_AgentTask_default_instance_);
}
inline ::llsf_msgs::AgentTask* BeaconSignal::release_task() {
  // @@protoc_insertion_point(field_release:llsf_msgs.BeaconSignal.task)
  clear_has_task();
  ::llsf_msgs::AgentTask* temp = task_;
  task_ = NULL;
  return temp;
}
inline ::llsf_msgs::AgentTask* BeaconSignal::mutable_task() {
  set_has_task();
  if (task_ == NULL) {
    auto* p = CreateMaybeMessage<::llsf_msgs::AgentTask>(GetArenaNoVirtual());
    task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.task)
  return task_;
}
inline void BeaconSignal::set_allocated_task(::llsf_msgs::AgentTask* task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_);
  }
  if (task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    set_has_task();
  } else {
    clear_has_task();
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:llsf_msgs.BeaconSignal.task)
}

// repeated .llsf_msgs.FinishedTask finished_tasks = 10;
inline int BeaconSignal::finished_tasks_size() const {
  return finished_tasks_.size();
}
inline void BeaconSignal::clear_finished_tasks() {
  finished_tasks_.Clear();
}
inline ::llsf_msgs::FinishedTask* BeaconSignal::mutable_finished_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:llsf_msgs.BeaconSignal.finished_tasks)
  return finished_tasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::llsf_msgs::FinishedTask >*
BeaconSignal::mutable_finished_tasks() {
  // @@protoc_insertion_point(field_mutable_list:llsf_msgs.BeaconSignal.finished_tasks)
  return &finished_tasks_;
}
inline const ::llsf_msgs::FinishedTask& BeaconSignal::finished_tasks(int index) const {
  // @@protoc_insertion_point(field_get:llsf_msgs.BeaconSignal.finished_tasks)
  return finished_tasks_.Get(index);
}
inline ::llsf_msgs::FinishedTask* BeaconSignal::add_finished_tasks() {
  // @@protoc_insertion_point(field_add:llsf_msgs.BeaconSignal.finished_tasks)
  return finished_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llsf_msgs::FinishedTask >&
BeaconSignal::finished_tasks() const {
  // @@protoc_insertion_point(field_list:llsf_msgs.BeaconSignal.finished_tasks)
  return finished_tasks_;
}

// -------------------------------------------------------------------

// FinishedTask

// required uint32 TaskId = 1;
inline bool FinishedTask::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishedTask::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishedTask::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishedTask::clear_taskid() {
  taskid_ = 0u;
  clear_has_taskid();
}
inline ::google::protobuf::uint32 FinishedTask::taskid() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.FinishedTask.TaskId)
  return taskid_;
}
inline void FinishedTask::set_taskid(::google::protobuf::uint32 value) {
  set_has_taskid();
  taskid_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.FinishedTask.TaskId)
}

// required bool successful = 2;
inline bool FinishedTask::has_successful() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishedTask::set_has_successful() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinishedTask::clear_has_successful() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinishedTask::clear_successful() {
  successful_ = false;
  clear_has_successful();
}
inline bool FinishedTask::successful() const {
  // @@protoc_insertion_point(field_get:llsf_msgs.FinishedTask.successful)
  return successful_;
}
inline void FinishedTask::set_successful(bool value) {
  set_has_successful();
  successful_ = value;
  // @@protoc_insertion_point(field_set:llsf_msgs.FinishedTask.successful)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace llsf_msgs

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::llsf_msgs::BeaconSignal_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llsf_msgs::BeaconSignal_CompType>() {
  return ::llsf_msgs::BeaconSignal_CompType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BeaconSignal_2eproto
